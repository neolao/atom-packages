{"index":"<h1>React Documentation</h1>  <p>The easiest way to get started with React is to use <a href=\"http://codepen.io/gaearon/pen/ZpvBNJ?editors=0010\">this Hello World example code on CodePen</a>. You don't need to install anything; you can just open it in another tab and follow along as we go through examples. If you'd rather use a local development environment, check out the <a href=\"installation\">Installation</a> page.</p> <p>The smallest React example looks like this:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(\n  &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n  document.getElementById('root')\n);</pre> <p>It renders a header saying \"Hello World\" on the page.</p> <p>The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</p> <h2 id=\"a-note-on-javascript\">\nA Note on JavaScript </h2> <p>React is a JavaScript library, and so it assumes you have a basic understanding of the JavaScript language. If you don't feel very confident, we recommend <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">refreshing your JavaScript knowledge</a> so you can follow along more easily.</p> <p>We also use some of the ES6 syntax in the examples. We try to use it sparingly because it's still relatively new, but we encourage you to get familiar with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">classes</a>, <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals\">template literals</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\"><code>let</code></a>, and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\"><code>const</code></a> statements. You can use <a href=\"http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact&amp;experimental=false&amp;loose=false&amp;spec=false&amp;code=const%20element%20%3D%20%3Ch1%3EHello%2C%20world!%3C%2Fh1%3E%3B%0Aconst%20container%20%3D%20document.getElementById('root')%3B%0AReactDOM.render(element%2C%20container)%3B%0A\">Babel REPL</a> to check what ES6 code compiles to.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/hello-world.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/hello-world.html</a>\n  </p>\n</div>\n","installation":"<h1> Installation </h1>  <p>React is flexible and can be used in a variety of projects. You can create new apps with it, but you can also gradually introduce it into an existing codebase without doing a rewrite.</p> <h2 id=\"trying-out-react\">\nTrying Out React </h2> <p>If you're just interested in playing around with React, you can use CodePen. Try starting from <a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\">this Hello World example code</a>. You don't need to install anything; you can just modify the code and see if it works.</p> <p>If you prefer to use your own text editor, you can also <a href=\"https://facebook.github.io/react/downloads/single-file-example.html\" download=\"hello.html\">download this HTML file</a>, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don't use it in production.</p> <h2 id=\"creating-a-single-page-application\">\nCreating a Single Page Application </h2> <p><a href=\"http://github.com/facebookincubator/create-react-app\">Create React App</a> is the best way to starting building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production.</p> <pre class=\"highlight\" data-language=\"bash\">npm install -g create-react-app\ncreate-react-app hello-world\ncd hello-world\nnpm start</pre> <p>Create React App doesn't handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses <a href=\"https://webpack.js.org/\">webpack</a>, <a href=\"http://babeljs.io/\">Babel</a> and <a href=\"http://eslint.org/\">ESLint</a> under the hood, but configures them for you.</p> <h2 id=\"adding-react-to-an-existing-application\">\nAdding React to an Existing Application </h2> <p>You don't need to rewrite your app to start using React.</p> <p>We recommend adding React to a small part of your application, such an individual widget, so you can see if it works well for your use case.</p> <p>While React <a href=\"react-without-es6\">can be used</a> without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of:</p> <ul> <li>A <strong>package manager</strong>, such as <a href=\"https://yarnpkg.com/\">Yarn</a> or <a href=\"https://www.npmjs.com/\">npm</a>. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</li> <li>A <strong>bundler</strong>, such as <a href=\"https://webpack.js.org/\">webpack</a> or <a href=\"http://browserify.org/\">Browserify</a>. It lets you write modular code and bundle it together into small packages to optimize load time.</li> <li>A <strong>compiler</strong> such as <a href=\"http://babeljs.io/\">Babel</a>. It lets you write modern JavaScript code that still works in older browsers.</li> </ul> <h3 id=\"installing-react\">\nInstalling React </h3> <p>We recommend using <a href=\"https://yarnpkg.com/\">Yarn</a> or <a href=\"https://www.npmjs.com/\">npm</a> for managing front-end dependencies. If you're new to package managers, the <a href=\"https://yarnpkg.com/en/docs/getting-started\">Yarn documentation</a> is a good place to get started.</p> <p>To install React with Yarn, run:</p> <pre class=\"highlight\" data-language=\"bash\">yarn init\nyarn add react react-dom</pre> <p>To install React with npm, run:</p> <pre class=\"highlight\" data-language=\"bash\">npm init\nnpm install --save react react-dom</pre> <p>Both Yarn and npm download packages from the <a href=\"http://npmjs.com/\">npm registry</a>.</p> <h3 id=\"enabling-es6-and-jsx\">\nEnabling ES6 and JSX </h3> <p>We recommend using React with <a href=\"http://babeljs.io/\">Babel</a> to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.</p> <p>The <a href=\"https://babeljs.io/docs/setup/\">Babel setup instructions</a> explain how to configure Babel in many different build environments. Make sure you install <a href=\"http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-\"><code>babel-preset-react</code></a> and <a href=\"http://babeljs.io/docs/plugins/preset-es2015/#basic-setup-with-the-cli-\"><code>babel-preset-es2015</code></a> and enable them in your <a href=\"http://babeljs.io/docs/usage/babelrc/\"><code>.babelrc</code> configuration</a>, and you're good to go.</p> <h3 id=\"hello-world-with-es6-and-jsx\">\nHello World with ES6 and JSX </h3> <p>We recommend using a bundler like <a href=\"https://webpack.js.org/\">webpack</a> or <a href=\"http://browserify.org/\">Browserify</a> so you can write modular code and bundle it together into small packages to optimize load time.</p> <p>The smallest React example looks like this:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n  document.getElementById('root')\n);</pre> <p>This code renders into a DOM element with the id of <code>root</code> so you need <code>&lt;div id=\"root\"&gt;&lt;/div&gt;</code> somewhere in your HTML file.</p> <p>Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library.</p> <h3 id=\"development-and-production-versions\">\nDevelopment and Production Versions </h3> <p>By default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app.</p> <h4 id=\"create-react-app\">\nCreate React App </h4> <p>If you use <a href=\"https://github.com/facebookincubator/create-react-app\">Create React App</a>, <code>npm run build</code> will create an optimized build of your app in the <code>build</code> folder.</p> <h4 id=\"webpack\">\nWebpack </h4> <p>Include both <code>DefinePlugin</code> and <code>UglifyJsPlugin</code> into your production Webpack configuration as described in <a href=\"https://webpack.js.org/guides/production-build/\">this guide</a>.</p> <h4 id=\"browserify\">\nBrowserify </h4> <p>Run Browserify with <code>NODE_ENV</code> environment variable set to <code>production</code> and use <a href=\"https://github.com/mishoo/UglifyJS\">UglifyJS</a> as the last build step so that development-only code gets stripped out.</p> <h3 id=\"using-a-cdn\">\nUsing a CDN </h3> <p>If you don't want to use npm to manage client packages, the <code>react</code> and <code>react-dom</code> npm packages also provide single-file distributions in <code>dist</code> folders, which are hosted on a CDN:</p> <pre class=\"highlight\" data-language=\"html\">&lt;script src=\"https://unpkg.com/react@15/dist/react.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"&gt;&lt;/script&gt;</pre> <p>The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at:</p> <pre class=\"highlight\" data-language=\"html\">&lt;script src=\"https://unpkg.com/react@15/dist/react.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"&gt;&lt;/script&gt;</pre> <p>To load a specific version of <code>react</code> and <code>react-dom</code>, replace <code>15</code> with the version number.</p> <p>If you use Bower, React is available via the <code>react</code> package.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/installation.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/installation.html</a>\n  </p>\n</div>\n","composition-vs-inheritance":"<h1> Composition vs Inheritance </h1>  <p>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</p> <p>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</p> <h2 id=\"containment\">\nContainment </h2> <p>Some components don't know their children ahead of time. This is especially common for components like <code>Sidebar</code> or <code>Dialog</code> that represent generic \"boxes\".</p> <p>We recommend that such components use the special <code>children</code> prop to pass children elements directly into their output:</p> <pre class=\"highlight\" data-language=\"js\">function FancyBorder(props) {\n  return (\n    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;\n      {props.children}\n    &lt;/div&gt;\n  );\n}</pre> <p>This lets other components pass arbitrary children to them by nesting the JSX:</p> <pre class=\"highlight\" data-language=\"js\">function WelcomeDialog() {\n  return (\n    &lt;FancyBorder color=\"blue\"&gt;\n      &lt;h1 className=\"Dialog-title\"&gt;\n        Welcome\n      &lt;/h1&gt;\n      &lt;p className=\"Dialog-message\"&gt;\n        Thank you for visiting our spacecraft!\n      &lt;/p&gt;\n    &lt;/FancyBorder&gt;\n  );\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/ozqNOV?editors=0010\">Try it on CodePen.</a></p> <p>Anything inside the <code>&lt;FancyBorder&gt;</code> JSX tag gets passed into the <code>FancyBorder</code> component as a <code>children</code> prop. Since <code>FancyBorder</code> renders <code>{props.children}</code> inside a <code>&lt;div&gt;</code>, the passed elements appear in the final output.</p> <p>While this is less common, sometimes you might need multiple \"holes\" in a component. In such cases you may come up with your own convention instead of using <code>children</code>:</p> <pre class=\"highlight\" data-language=\"js\">function SplitPane(props) {\n  return (\n    &lt;div className=\"SplitPane\"&gt;\n      &lt;div className=\"SplitPane-left\"&gt;\n        {props.left}\n      &lt;/div&gt;\n      &lt;div className=\"SplitPane-right\"&gt;\n        {props.right}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction App() {\n  return (\n    &lt;SplitPane\n      left={\n        &lt;Contacts /&gt;\n      }\n      right={\n        &lt;Chat /&gt;\n      } /&gt;\n  );\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/gwZOJp?editors=0010\">Try it on CodePen.</a></p> <p>React elements like <code>&lt;Contacts /&gt;</code> and <code>&lt;Chat /&gt;</code> are just objects, so you can pass them as props like any other data.</p> <h2 id=\"specialization\">\nSpecialization </h2> <p>Sometimes we think about components as being \"special cases\" of other components. For example, we might say that a <code>WelcomeDialog</code> is a special case of <code>Dialog</code>.</p> <p>In React, this is also achieved by composition, where a more \"specific\" component renders a more \"generic\" one and configures it with props:</p> <pre class=\"highlight\" data-language=\"js\">function Dialog(props) {\n  return (\n    &lt;FancyBorder color=\"blue\"&gt;\n      &lt;h1 className=\"Dialog-title\"&gt;\n        {props.title}\n      &lt;/h1&gt;\n      &lt;p className=\"Dialog-message\"&gt;\n        {props.message}\n      &lt;/p&gt;\n    &lt;/FancyBorder&gt;\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    &lt;Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" /&gt;\n  );\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/kkEaOZ?editors=0010\">Try it on CodePen.</a></p> <p>Composition works equally well for components defined as classes:</p> <pre class=\"highlight\" data-language=\"js\">function Dialog(props) {\n  return (\n    &lt;FancyBorder color=\"blue\"&gt;\n      &lt;h1 className=\"Dialog-title\"&gt;\n        {props.title}\n      &lt;/h1&gt;\n      &lt;p className=\"Dialog-message\"&gt;\n        {props.message}\n      &lt;/p&gt;\n      {props.children}\n    &lt;/FancyBorder&gt;\n  );\n}\n\nclass SignUpDialog extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSignUp = this.handleSignUp.bind(this);\n    this.state = {login: ''};\n  }\n\n  render() {\n    return (\n      &lt;Dialog title=\"Mars Exploration Program\"\n              message=\"How should we refer to you?\"&gt;\n        &lt;input value={this.state.login}\n               onChange={this.handleChange} /&gt;\n        &lt;button onClick={this.handleSignUp}&gt;\n          Sign Me Up!\n        &lt;/button&gt;\n      &lt;/Dialog&gt;\n    );\n  }\n\n  handleChange(e) {\n    this.setState({login: e.target.value});\n  }\n\n  handleSignUp() {\n    alert(`Welcome aboard, ${this.state.login}!`);\n  }\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/gwZbYa?editors=0010\">Try it on CodePen.</a></p> <h2 id=\"so-what-about-inheritance\">\nSo What About Inheritance? </h2> <p>At Facebook, we use React in thousands of components, and we haven't found any use cases where we would recommend creating component inheritance hierarchies.</p> <p>Props and composition give you all the flexibility you need to customize a component's look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</p> <p>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/composition-vs-inheritance.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/composition-vs-inheritance.html</a>\n  </p>\n</div>\n","react-without-jsx":"<h1> React Without JSX </h1>  <p>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don't want to set up compilation in your build environment.</p> <p>Each JSX element is just syntactic sugar for calling <code>React.createElement(component, props, ...children)</code>. So, anything you can do with JSX can also be done with just plain JavaScript.</p> <p>For example, this code written with JSX:</p> <pre class=\"highlight\" data-language=\"js\">class Hello extends React.Component {\n  render() {\n    return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;;\n  }\n}\n\nReactDOM.render(\n  &lt;Hello toWhat=\"World\" /&gt;,\n  document.getElementById('root')\n);</pre> <p>can be compiled to this code that does not use JSX:</p> <pre class=\"highlight\" data-language=\"js\">class Hello extends React.Component {\n  render() {\n    return React.createElement('div', null, `Hello ${this.props.toWhat}`);\n  }\n}\n\nReactDOM.render(\n  React.createElement(Hello, {toWhat: 'World'}, null),\n  document.getElementById('root')\n);</pre> <p>If you're curious to see more examples of how JSX is converted to JavaScript, you can try out <a href=\"https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D\">the online Babel compiler</a>.</p> <p>The component can either be provided as a string, or as a subclass of <code>React.Component</code>, or a plain function for stateless components.</p> <p>If you get tired of typing <code>React.createElement</code> so much, one common pattern is to assign a shorthand:</p> <pre class=\"highlight\" data-language=\"js\">const e = React.createElement;\n\nReactDOM.render(\n  e('div', null, 'Hello World'),\n  document.getElementById('root')\n);</pre> <p>If you use this shorthand form for <code>React.createElement</code>, it can be almost as convenient to use React without JSX.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-without-jsx.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-without-jsx.html</a>\n  </p>\n</div>\n","rendering-elements":"<h1> Rendering Elements </h1>  <p>Elements are the smallest building blocks of React apps.</p> <p>An element describes what you want to see on the screen:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</pre> <p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p> <blockquote>  <p>One might confuse elements with a more widely known concept of \"components\". We will introduce components in the <a href=\"components-and-props\">next section</a>. Elements are what components are \"made of\", and we encourage you to read this section before jumping ahead.</p> </blockquote> <h2 id=\"rendering-an-element-into-the-dom\">\nRendering an Element into the DOM </h2> <p>Let's say there is a <code>&lt;div&gt;</code> somewhere in your HTML file:</p> <pre class=\"highlight\" data-language=\"html\">&lt;div id=\"root\"&gt;&lt;/div&gt;</pre> <p>We call this a \"root\" DOM node because everything inside it will be managed by React DOM.</p> <p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p> <p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=1010\">Try it on CodePen.</a></p> <p>It displays \"Hello World\" on the page.</p> <h2 id=\"updating-the-rendered-element\">\nUpdating the Rendered Element </h2> <p>React elements are <a href=\"https://en.wikipedia.org/wiki/Immutable_object\">immutable</a>. Once you create an element, you can't change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p> <p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p> <p>Consider this ticking clock example:</p> <pre class=\"highlight\" data-language=\"js\">function tick() {\n  const element = (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);</pre> <p><a href=\"http://codepen.io/gaearon/pen/gwoJZk?editors=0010\">Try it on CodePen.</a></p> <p>It calls <code>ReactDOM.render()</code> every second from a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval\"><code>setInterval()</code></a> callback.</p> <blockquote>  <p>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into <a href=\"state-and-lifecycle\">stateful components</a>.</p> <p>We recommend that you don't skip topics because they build on each other.</p> </blockquote> <h2 id=\"react-only-updates-whats-necessary\">\nReact Only Updates What's Necessary </h2> <p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p> <p>You can verify by inspecting the <a href=\"http://codepen.io/gaearon/pen/gwoJZk?editors=0010\">last example</a> with the browser tools:</p> <p><img src=\"https://facebook.github.io/react/img/docs/granular-dom-updates.gif\" alt=\"DOM inspector showing granular updates\"></p> <p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p> <p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/rendering-elements.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/rendering-elements.html</a>\n  </p>\n</div>\n","refs-and-the-dom":"<h1> Refs and the DOM </h1>  <p>In the typical React dataflow, <a href=\"components-and-props\">props</a> are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</p> <h2 id=\"the-ref-callback-attribute\">\nThe ref Callback Attribute </h2> <p>React supports a special attribute that you can attach to any component. The <code>ref</code> attribute takes a callback function, and the callback will be executed immediately after the component is mounted or unmounted.</p> <p>When the <code>ref</code> attribute is used on an HTML element, the <code>ref</code> callback receives the underlying DOM element as its argument. For example, this code uses the <code>ref</code> callback to store a reference to a DOM node:</p> <pre class=\"highlight\" data-language=\"javascript\">class CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.focus = this.focus.bind(this);\n  }\n\n  focus() {\n    // Explicitly focus the text input using the raw DOM API\n    this.textInput.focus();\n  }\n\n  render() {\n    // Use the `ref` callback to store a reference to the text input DOM\n    // element in this.textInput.\n    return (\n      &lt;div&gt;\n        &lt;input\n          type=\"text\"\n          ref={(input) =&gt; { this.textInput = input; }} /&gt;\n        &lt;input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focus}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p>React will call the <code>ref</code> callback with the DOM element when the component mounts, and call it with <code>null</code> when it unmounts.</p> <p>Using the <code>ref</code> callback just to set a property on the class is a common pattern for accessing DOM elements. The preferred way is to set the property in the <code>ref</code> callback like in the above example. There is even a shorter way to write it: <code>ref={input =&gt; this.textInput = input}</code>. </p> <p>If you worked with React before, you might be familiar with an older API where the <code>ref</code> attribute is a string, like <code>\"textInput\"</code>, and the DOM node is accessed as <code>this.refs.textInput</code>. We advise against it because string refs have <a href=\"https://github.com/facebook/react/pull/8333#issuecomment-271648615\">some issues</a>, are considered legacy, and <strong>are likely to be removed in one of the future releases</strong>. If you're currently using <code>this.refs.textInput</code> to access refs, we recommend the callback pattern instead.</p> <p>When the <code>ref</code> attribute is used on a custom component, the <code>ref</code> callback receives the mounted instance of the component as its argument. For example, if we wanted to wrap the <code>CustomTextInput</code> above to simulate it being clicked immediately after mounting:</p> <pre class=\"highlight\" data-language=\"javascript\">class AutoFocusTextInput extends React.Component {\n  componentDidMount() {\n    this.textInput.focus();\n  }\n\n  render() {\n    return (\n      &lt;CustomTextInput\n        ref={(input) =&gt; { this.textInput = input; }} /&gt;\n    );\n  }\n}</pre> <p>You may not use the <code>ref</code> attribute on functional components because they don't have instances. You can, however, use the <code>ref</code> attribute inside the <code>render</code> function of a functional component:</p> <pre class=\"highlight\" data-language=\"javascript\">function CustomTextInput(props) {\n  // textInput must be declared here so the ref callback can refer to it\n  let textInput = null;\n\n  function handleClick() {\n    textInput.focus();\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        type=\"text\"\n        ref={(input) =&gt; { textInput = input; }} /&gt;\n      &lt;input\n        type=\"button\"\n        value=\"Focus the text input\"\n        onClick={handleClick}\n      /&gt;\n    &lt;/div&gt;\n  );  \n}</pre>\n<h3 id=\"dont-overuse-refs\">\nDon't Overuse Refs </h3> <p>Your first inclination may be to use refs to \"make things happen\" in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to \"own\" that state is at a higher level in the hierarchy. See the <a href=\"lifting-state-up\">Lifting State Up</a> guide for examples of this.</p> <h3 id=\"caveats\">\nCaveats </h3> <p>If the <code>ref</code> callback is defined as an inline function, it will get called twice during updates, first with <code>null</code> and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the <code>ref</code> callback as a bound method on the class, but note that it shouldn't matter in most cases.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/refs-and-the-dom.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>\n  </p>\n</div>\n","thinking-in-react":"<h1> Thinking in React </h1>  <p>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</p> <p>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we'll walk you through the thought process of building a searchable product data table using React.</p> <h2 id=\"start-with-a-mock\">\nStart With A Mock </h2> <p>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</p> <p><img src=\"https://facebook.github.io/react/img/blog/thinking-in-react-mock.png\" alt=\"Mockup\"></p> <p>Our JSON API returns some data that looks like this:</p> <pre class=\"highlight\" data-language=\"text\">[\n  {category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"},\n  {category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"},\n  {category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"},\n  {category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"},\n  {category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"},\n  {category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"}\n];</pre>\n<h2 id=\"step-1-break-the-ui-into-a-component-hierarchy\">\nStep 1: Break The UI Into A Component Hierarchy </h2> <p>The first thing you'll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you're working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</p> <p>But how do you know what should be its own component? Just use the same techniques for deciding if you should create a new function or object. One such technique is the <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\">single responsibility principle</a>, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</p> <p>Since you're often displaying a JSON data model to a user, you'll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That's because UI and data models tend to adhere to the same <em>information architecture</em>, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model.</p> <p><img src=\"https://facebook.github.io/react/img/blog/thinking-in-react-components.png\" alt=\"Component diagram\"></p> <p>You'll see here that we have five components in our simple app. We've italicized the data each component represents.</p> <ol> <li>\n<strong><code>FilterableProductTable</code> (orange):</strong> contains the entirety of the example</li> <li>\n<strong><code>SearchBar</code> (blue):</strong> receives all <em>user input</em>\n</li> <li>\n<strong><code>ProductTable</code> (green):</strong> displays and filters the <em>data collection</em> based on <em>user input</em>\n</li> <li>\n<strong><code>ProductCategoryRow</code> (turquoise):</strong> displays a heading for each <em>category</em>\n</li> <li>\n<strong><code>ProductRow</code> (red):</strong> displays a row for each <em>product</em>\n</li> </ol> <p>If you look at <code>ProductTable</code>, you'll see that the table header (containing the \"Name\" and \"Price\" labels) isn't its own component. This is a matter of preference, and there's an argument to be made either way. For this example, we left it as part of <code>ProductTable</code> because it is part of rendering the <em>data collection</em> which is <code>ProductTable</code>'s responsibility. However, if this header grows to be complex (i.e. if we were to add affordances for sorting), it would certainly make sense to make this its own <code>ProductTableHeader</code> component.</p> <p>Now that we've identified the components in our mock, let's arrange them into a hierarchy. This is easy. Components that appear within another component in the mock should appear as a child in the hierarchy:</p> <ul> <li>\n<code>FilterableProductTable</code> <ul> <li><code>SearchBar</code></li> <li>\n<code>ProductTable</code> <ul> <li><code>ProductCategoryRow</code></li> <li><code>ProductRow</code></li> </ul>\n</li> </ul>\n</li> </ul> <h2 id=\"step-2-build-a-static-version-in-react\">\nStep 2: Build A Static Version in React </h2> <p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"vXpAgj\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/lacker/pen/vXpAgj/\">Thinking In React: Step 2</a> on <a href=\"http://codepen.io\">CodePen</a>.</p>  <p>Now that you have your component hierarchy, it's time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It's best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We'll see why.</p> <p>To build a static version of your app that renders your data model, you'll want to build components that reuse other components and pass data using <em>props</em>. <em>props</em> are a way of passing data from parent to child. If you're familiar with the concept of <em>state</em>, <strong>don't use state at all</strong> to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don't need it.</p> <p>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with <code>FilterableProductTable</code>) or with the ones lower in it (<code>ProductRow</code>). In simpler examples, it's usually easier to go top-down, and on larger projects, it's easier to go bottom-up and write tests as you build.</p> <p>At the end of this step, you'll have a library of reusable components that render your data model. The components will only have <code>render()</code> methods since this is a static version of your app. The component at the top of the hierarchy (<code>FilterableProductTable</code>) will take your data model as a prop. If you make a change to your underlying data model and call <code>ReactDOM.render()</code> again, the UI will be updated. It's easy to see how your UI is updated and where to make changes since there's nothing complicated going on. React's <strong>one-way data flow</strong> (also called <em>one-way binding</em>) keeps everything modular and fast.</p> <p>Simply refer to the <a href=\"https://facebook.github.io/react/docs/\">React docs</a> if you need help executing this step.</p> <h3 id=\"a-brief-interlude-props-vs-state\">\nA Brief Interlude: Props vs State </h3> <p>There are two types of \"model\" data in React: props and state. It's important to understand the distinction between the two; skim <a href=\"state-and-lifecycle\">the official React docs</a> if you aren't sure what the difference is.</p> <h2 id=\"step-3-identify-the-minimal-but-complete-representation-of-ui-state\">\nStep 3: Identify The Minimal (but complete) Representation Of UI State </h2> <p>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with <strong>state</strong>.</p> <p>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is DRY: <em>Don't Repeat Yourself</em>. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you're building a TODO list, just keep an array of the TODO items around; don't keep a separate state variable for the count. Instead, when you want to render the TODO count, simply take the length of the TODO items array.</p> <p>Think of all of the pieces of data in our example application. We have:</p> <ul> <li>The original list of products</li> <li>The search text the user has entered</li> <li>The value of the checkbox</li> <li>The filtered list of products</li> </ul> <p>Let's go through each one and figure out which one is state. Simply ask three questions about each piece of data:</p> <ol> <li>Is it passed in from a parent via props? If so, it probably isn't state.</li> <li>Does it remain unchanged over time? If so, it probably isn't state.</li> <li>Can you compute it based on any other state or props in your component? If so, it isn't state.</li> </ol> <p>The original list of products is passed in as props, so that's not state. The search text and the checkbox seem to be state since they change over time and can't be computed from anything. And finally, the filtered list of products isn't state because it can be computed by combining the original list of products with the search text and value of the checkbox.</p> <p>So finally, our state is:</p> <ul> <li>The search text the user has entered</li> <li>The value of the checkbox</li> </ul> <h2 id=\"step-4-identify-where-your-state-should-live\">\nStep 4: Identify Where Your State Should Live </h2> <p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"ORzEkG\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/lacker/pen/ORzEkG/\">Thinking In React: Step 4</a> by Kevin Lacker (<a href=\"http://codepen.io/lacker\">@lacker</a>) on <a href=\"http://codepen.io\">CodePen</a>.</p>  <p>OK, so we've identified what the minimal set of app state is. Next, we need to identify which component mutates, or <em>owns</em>, this state.</p> <p>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. <strong>This is often the most challenging part for newcomers to understand,</strong> so follow these steps to figure it out:</p> <p>For each piece of state in your application:</p> <ul> <li>Identify every component that renders something based on that state.</li> <li>Find a common owner component (a single component above all the components that need the state in the hierarchy).</li> <li>Either the common owner or another component higher up in the hierarchy should own the state.</li> <li>If you can't find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</li> </ul> <p>Let's run through this strategy for our application:</p> <ul> <li>\n<code>ProductTable</code> needs to filter the product list based on state and <code>SearchBar</code> needs to display the search text and checked state.</li> <li>The common owner component is <code>FilterableProductTable</code>.</li> <li>It conceptually makes sense for the filter text and checked value to live in <code>FilterableProductTable</code>\n</li> </ul> <p>Cool, so we've decided that our state lives in <code>FilterableProductTable</code>. First, add an instance property <code>this.state = {filterText: '', inStockOnly: false}</code> to <code>FilterableProductTable</code>'s <code>constructor</code> to reflect the initial state of your application. Then, pass <code>filterText</code> and <code>inStockOnly</code> to <code>ProductTable</code> and <code>SearchBar</code> as a prop. Finally, use these props to filter the rows in <code>ProductTable</code> and set the values of the form fields in <code>SearchBar</code>.</p> <p>You can start seeing how your application will behave: set <code>filterText</code> to <code>\"ball\"</code> and refresh your app. You'll see that the data table is updated correctly.</p> <h2 id=\"step-5-add-inverse-data-flow\">\nStep 5: Add Inverse Data Flow </h2> <p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"JbYQvL\" data-default-tab=\"js,result\" data-user=\"snakajima\" data-embed-version=\"2\" data-pen-title=\"Thinking In React: Step 5\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/snakajima/pen/JbYQvL/\">Thinking In React: Step 5</a> on <a href=\"http://codepen.io\">CodePen</a>.</p>  <p>So far, we've built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it's time to support data flowing the other way: the form components deep in the hierarchy need to update the state in <code>FilterableProductTable</code>.</p> <p>React makes this data flow explicit to make it easy to understand how your program works, but it does require a little more typing than traditional two-way data binding.</p> <p>If you try to type or check the box in the current version of the example, you'll see that React ignores your input. This is intentional, as we've set the <code>value</code> prop of the <code>input</code> to always be equal to the <code>state</code> passed in from <code>FilterableProductTable</code>.</p> <p>Let's think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, <code>FilterableProductTable</code> will pass a callback to <code>SearchBar</code> that will fire whenever the state should be updated. We can use the <code>onChange</code> event on the inputs to be notified of it. And the callback passed by <code>FilterableProductTable</code> will call <code>setState()</code>, and the app will be updated.</p> <p>Though this sounds complex, it's really just a few lines of code. And it's really explicit how your data is flowing throughout the app.</p> <h2 id=\"and-thats-it\">\nAnd That's It </h2> <p>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you're used to, remember that code is read far more than it's written, and it's extremely easy to read this modular, explicit code. As you start to build large libraries of components, you'll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/thinking-in-react.html</a>\n  </p>\n</div>\n","introducing-jsx":"<h1> Introducing JSX </h1>  <p>Consider this variable declaration:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</pre> <p>This funny tag syntax is neither a string nor HTML.</p> <p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p> <p>JSX produces React \"elements\". We will explore rendering them to the DOM in the <a href=\"rendering-elements\">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p> <h3 id=\"embedding-expressions-in-jsx\">\nEmbedding Expressions in JSX </h3> <p>You can embed any <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions\">JavaScript expression</a> in JSX by wrapping it in curly braces.</p> <p>For example, <code>2 + 2</code>, <code>user.name</code>, and <code>formatName(user)</code> are all valid expressions:</p> <pre class=\"highlight\" data-language=\"js\">function formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  &lt;h1&gt;\n    Hello, {formatName(user)}!\n  &lt;/h1&gt;\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/PGEjdG?editors=0010\">Try it on CodePen.</a></p> <p>We split JSX over multiple lines for readability. While it isn't mandatory, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href=\"http://stackoverflow.com/q/2846283\">automatic semicolon insertion</a>.</p> <h3 id=\"jsx-is-an-expression-too\">\nJSX is an Expression Too </h3> <p>After compilation, JSX expressions become regular JavaScript objects.</p> <p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p> <pre class=\"highlight\" data-language=\"js\">function getGreeting(user) {\n  if (user) {\n    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;\n  }\n  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;\n}</pre>\n<h3 id=\"specifying-attributes-with-jsx\">\nSpecifying Attributes with JSX </h3> <p>You may use quotes to specify string literals as attributes:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt;;</pre> <p>You may also use curly braces to embed a JavaScript expression in an attribute:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</pre>\n<h3 id=\"specifying-children-with-jsx\">\nSpecifying Children with JSX </h3> <p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;img src={user.avatarUrl} /&gt;;</pre> <p>JSX tags may contain children:</p> <pre class=\"highlight\" data-language=\"js\">const element = (\n  &lt;div&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;h2&gt;Good to see you here.&lt;/h2&gt;\n  &lt;/div&gt;\n);</pre> <blockquote> <p><strong>Caveat:</strong></p> <p>Since JSX is closer to JavaScript than HTML, React DOM uses <code>camelCase</code> property naming convention instead of HTML attribute names.</p> <p>For example, <code>class</code> becomes <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/className\"><code>className</code></a> in JSX, and <code>tabindex</code> becomes <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex\"><code>tabIndex</code></a>.</p> </blockquote> <h3 id=\"jsx-prevents-injection-attacks\">\nJSX Prevents Injection Attacks </h3> <p>It is safe to embed user input in JSX:</p> <pre class=\"highlight\" data-language=\"js\">const title = response.potentiallyMaliciousInput;\n// This is safe:\nconst element = &lt;h1&gt;{title}&lt;/h1&gt;;</pre> <p>By default, React DOM <a href=\"http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html\">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that's not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS (cross-site-scripting)</a> attacks.</p> <h3 id=\"jsx-represents-objects\">\nJSX Represents Objects </h3> <p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p> <p>These two examples are identical:</p> <pre class=\"highlight\" data-language=\"js\">const element = (\n  &lt;h1 className=\"greeting\"&gt;\n    Hello, world!\n  &lt;/h1&gt;\n);</pre>\n<pre class=\"highlight\" data-language=\"js\">const element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);</pre> <p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p> <pre class=\"highlight\" data-language=\"js\">// Note: this structure is simplified\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n};</pre> <p>These objects are called \"React elements\". You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p> <p>We will explore rendering React elements to the DOM in the next section.</p> <blockquote> <p><strong>Tip:</strong></p> <p>We recommend searching for a \"Babel\" syntax scheme for your editor of choice so that both ES6 and JSX code is properly highlighted.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/introducing-jsx.html</a>\n  </p>\n</div>\n","reconciliation":"<h1> Reconciliation </h1>  <p>React provides a declarative API so that you don't have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React's \"diffing\" algorithm so that component updates are predictable while being fast enough for high-performance apps.</p> <h2 id=\"motivation\">\nMotivation </h2> <p>When you use React, at a single point in time you can think of the <code>render()</code> function as creating a tree of React elements. On the next state or props update, that <code>render()</code> function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</p> <p>There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the <a href=\"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\">state of the art algorithms</a> have a complexity in the order of O(n<sup>3</sup>) where n is the number of elements in the tree.</p> <p>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</p> <ol> <li>Two elements of different types will produce different trees.</li> <li>The developer can hint at which child elements may be stable across different renders with a <code>key</code> prop.</li> </ol> <p>In practice, these assumptions are valid for almost all practical use cases.</p> <h2 id=\"the-diffing-algorithm\">\nThe Diffing Algorithm </h2> <p>When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.</p> <h3 id=\"elements-of-different-types\">\nElements Of Different Types </h3> <p>Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from <code>&lt;a&gt;</code> to <code>&lt;img&gt;</code>, or from <code>&lt;Article&gt;</code> to <code>&lt;Comment&gt;</code>, or from <code>&lt;Button&gt;</code> to <code>&lt;div&gt;</code> - any of those will lead to a full rebuild.</p> <p>When tearing down a tree, old DOM nodes are destroyed. Component instances receive <code>componentWillUnmount()</code>. When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive <code>componentWillMount()</code> and then <code>componentDidMount()</code>. Any state associated with the old tree is lost.</p> <p>Any components below the root will also get unmounted and have their state destroyed. For example, when diffing:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;div&gt;\n  &lt;Counter /&gt;\n&lt;/div&gt;\n\n&lt;span&gt;\n  &lt;Counter /&gt;\n&lt;/span&gt;</pre> <p>This will destroy the old <code>Counter</code> and remount a new one.</p> <h3 id=\"dom-elements-of-the-same-type\">\nDOM Elements Of The Same Type </h3> <p>When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;div className=\"before\" title=\"stuff\" /&gt;\n\n&lt;div className=\"after\" title=\"stuff\" /&gt;</pre> <p>By comparing these two elements, React knows to only modify the <code>className</code> on the underlying DOM node.</p> <p>When updating <code>style</code>, React also knows to update only the properties that changed. For example:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;div style={{color: 'red', fontWeight: 'bold'}} /&gt;\n\n&lt;div style={{color: 'green', fontWeight: 'bold'}} /&gt;</pre> <p>When converting between these two elements, React knows to only modify the <code>color</code> style, not the <code>fontWeight</code>.</p> <p>After handling the DOM node, React then recurses on the children.</p> <h3 id=\"component-elements-of-the-same-type\">\nComponent Elements Of The Same Type </h3> <p>When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls <code>componentWillReceiveProps()</code> and <code>componentWillUpdate()</code> on the underlying instance.</p> <p>Next, the <code>render()</code> method is called and the diff algorithm recurses on the previous result and the new result.</p> <h3 id=\"recursing-on-children\">\nRecursing On Children </h3> <p>By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there's a difference.</p> <p>For example, when adding an element at the end of the children, converting between these two trees works well:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;ul&gt;\n  &lt;li&gt;first&lt;/li&gt;\n  &lt;li&gt;second&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;/li&gt;\n  &lt;li&gt;second&lt;/li&gt;\n  &lt;li&gt;third&lt;/li&gt;\n&lt;/ul&gt;</pre> <p>React will match the two <code>&lt;li&gt;first&lt;/li&gt;</code> trees, match the two <code>&lt;li&gt;second&lt;/li&gt;</code> trees, and then insert the <code>&lt;li&gt;third&lt;/li&gt;</code> tree.</p> <p>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;ul&gt;\n  &lt;li&gt;Duke&lt;/li&gt;\n  &lt;li&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;/li&gt;\n  &lt;li&gt;Duke&lt;/li&gt;\n  &lt;li&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;</pre> <p>React will mutate every child instead of realizing it can keep the <code>&lt;li&gt;Duke&lt;/li&gt;</code> and <code>&lt;li&gt;Villanova&lt;/li&gt;</code> subtrees intact. This inefficiency can be a problem.</p> <h3 id=\"keys\">\nKeys </h3> <p>In order to solve this issue, React supports a <code>key</code> attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a <code>key</code> to our inefficient example above can make the tree conversion efficient:</p> <pre class=\"highlight\" data-language=\"xml\">&lt;ul&gt;\n  &lt;li key=\"2015\"&gt;Duke&lt;/li&gt;\n  &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n  &lt;li key=\"2014\"&gt;Connecticut&lt;/li&gt;\n  &lt;li key=\"2015\"&gt;Duke&lt;/li&gt;\n  &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;</pre> <p>Now React knows that the element with key <code>'2014'</code> is the new one, and the elements with the keys <code>'2015'</code> and <code>'2016'</code> have just moved.</p> <p>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</p> <pre class=\"highlight\" data-language=\"js\">&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</pre> <p>When that's not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</p> <p>As a last resort, you can pass item's index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.</p> <h2 id=\"tradeoffs\">\nTradeoffs </h2> <p>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. We are regularly refining the heuristics in order to make common use cases faster.</p> <p>In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree.</p> <p>Because React relies on heuristics, if the assumptions behind them are not met, performance will suffer.</p> <ol> <li><p>The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven't found this to be an issue.</p></li> <li><p>Keys should be stable, predictable, and unique. Unstable keys (like those produced by <code>Math.random()</code>) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</p></li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/reconciliation.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/reconciliation.html</a>\n  </p>\n</div>\n","web-components":"<h1> Web Components </h1>  <p>React and <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\">Web Components</a> are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</p> <p>Most people who use React don't use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</p> <h2 id=\"using-web-components-in-react\">\nUsing Web Components in React </h2>\n<pre class=\"highlight\" data-language=\"javascript\">class HelloMessage extends React.Component {\n  render() {\n    return &lt;div&gt;Hello &lt;x-search&gt;{this.props.name}&lt;/x-search&gt;!&lt;/div&gt;;\n  }\n}</pre> <blockquote>  <p>Web Components often expose an imperative API. For instance, a <code>video</code> Web Component might expose <code>play()</code> and <code>pause()</code> functions. To access the imperative APIs of a Web Component, you will need to use a ref to interact with the DOM node directly. If you are using third-party Web Components, the best solution is to write a React component that behaves as a wrapper for your Web Component.</p> <p>Events emitted by a Web Component may not properly propagate through a React render tree. You will need to manually attach event handlers to handle these events within your React components.</p> </blockquote> <p>One common confusion is that Web Components use \"class\" instead of \"className\".</p> <pre class=\"highlight\" data-language=\"javascript\">function BrickFlipbox() {\n  return (\n    &lt;brick-flipbox class=\"demo\"&gt;\n      &lt;div&gt;front&lt;/div&gt;\n      &lt;div&gt;back&lt;/div&gt;\n    &lt;/brick-flipbox&gt;\n  );\n}</pre>\n<h2 id=\"using-react-in-your-web-components\">\nUsing React in your Web Components </h2>\n<pre class=\"highlight\" data-language=\"javascript\">const proto = Object.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: function() {\n      const mountPoint = document.createElement('span');\n      this.createShadowRoot().appendChild(mountPoint);\n\n      const name = this.getAttribute('name');\n      const url = 'https://www.google.com/search?q=' + encodeURIComponent(name);\n      ReactDOM.render(&lt;a href={url}&gt;{name}&lt;/a&gt;, mountPoint);\n    }\n  }\n});\ndocument.registerElement('x-search', {prototype: proto});</pre> <p>You can also check out this <a href=\"https://github.com/facebook/react/tree/master/examples/webcomponents\">complete Web Components example on GitHub</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/web-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/web-components.html</a>\n  </p>\n</div>\n","typechecking-with-proptypes":"<h1> Typechecking With PropTypes </h1>  <p>As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like <a href=\"https://flowtype.org/\">Flow</a> or <a href=\"https://www.typescriptlang.org/\">TypeScript</a> to typecheck your whole application. But even if you don't use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special <code>propTypes</code> property:</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  render() {\n    return (\n      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: React.PropTypes.string\n};</pre> <p><code>React.PropTypes</code> exports a range of validators that can be used to make sure the data you receive is valid. In this example, we're using <code>React.PropTypes.string</code>. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. For performance reasons, <code>propTypes</code> is only checked in development mode.</p> <h3 id=\"react.proptypes\">\nReact.PropTypes </h3> <p>Here is an example documenting the different validators provided:</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: React.PropTypes.array,\n  optionalBool: React.PropTypes.bool,\n  optionalFunc: React.PropTypes.func,\n  optionalNumber: React.PropTypes.number,\n  optionalObject: React.PropTypes.object,\n  optionalString: React.PropTypes.string,\n  optionalSymbol: React.PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: React.PropTypes.node,\n\n  // A React element.\n  optionalElement: React.PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: React.PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: React.PropTypes.oneOfType([\n    React.PropTypes.string,\n    React.PropTypes.number,\n    React.PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: React.PropTypes.shape({\n    color: React.PropTypes.string,\n    fontSize: React.PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: React.PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: React.PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: React.PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};</pre>\n<h3 id=\"requiring-single-child\">\nRequiring Single Child </h3> <p>With <code>React.PropTypes.element</code> you can specify that only a single child can be passed to a component as children.</p> <pre class=\"highlight\" data-language=\"javascript\">class MyComponent extends React.Component {\n  render() {\n    // This must be exactly one element or it will warn.\n    const children = this.props.children;\n    return (\n      &lt;div&gt;\n        {children}\n      &lt;/div&gt;\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: React.PropTypes.element.isRequired\n};</pre>\n<h3 id=\"default-prop-values\">\nDefault Prop Values </h3> <p>You can define default values for your <code>props</code> by assigning to the special <code>defaultProps</code> property:</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  render() {\n    return (\n      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;\n    );\n  }\n}\n\n// Specifies the default values for props:\nGreeting.defaultProps = {\n  name: 'Stranger'\n};\n\n// Renders \"Hello, Stranger\":\nReactDOM.render(\n  &lt;Greeting /&gt;,\n  document.getElementById('example')\n);</pre> <p>The <code>defaultProps</code> will be used to ensure that <code>this.props.name</code> will have a value if it was not specified by the parent component. The <code>propTypes</code> typechecking happens after <code>defaultProps</code> are resolved, so typechecking will also apply to the <code>defaultProps</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/typechecking-with-proptypes.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a>\n  </p>\n</div>\n","jsx-in-depth":"<h1> JSX In Depth </h1>  <p>Fundamentally, JSX just provides syntactic sugar for the <code>React.createElement(component, props, ...children)</code> function. The JSX code:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyButton color=\"blue\" shadowSize={2}&gt;\n  Click Me\n&lt;/MyButton&gt;</pre> <p>compiles into:</p> <pre class=\"highlight\" data-language=\"js\">React.createElement(\n  MyButton,\n  {color: 'blue', shadowSize: 2},\n  'Click Me'\n)</pre> <p>You can also use the self-closing form of the tag if there are no children. So:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div className=\"sidebar\" /&gt;</pre> <p>compiles into:</p> <pre class=\"highlight\" data-language=\"js\">React.createElement(\n  'div',\n  {className: 'sidebar'},\n  null\n)</pre> <p>If you want to test out how some specific JSX is converted into JavaScript, you can try out <a href=\"https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D\">the online Babel compiler</a>.</p> <h2 id=\"specifying-the-react-element-type\">\nSpecifying The React Element Type </h2> <p>The first part of a JSX tag determines the type of the React element.</p> <p>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX <code>&lt;Foo /&gt;</code> expression, <code>Foo</code> must be in scope.</p> <h3 id=\"react-must-be-in-scope\">\nReact Must Be in Scope </h3> <p>Since JSX compiles into calls to <code>React.createElement</code>, the <code>React</code> library must also always be in scope from your JSX code.</p> <p>For example, both of the imports are necessary in this code, even though <code>React</code> and <code>CustomButton</code> are not directly referenced from JavaScript:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\nimport CustomButton from './CustomButton';\n\nfunction WarningButton() {\n  // return React.createElement(CustomButton, {color: 'red'}, null);\n  return &lt;CustomButton color=\"red\" /&gt;;\n}</pre> <p>If you don't use a JavaScript bundler and added React as a script tag, it is already in scope as a <code>React</code> global.</p> <h3 id=\"using-dot-notation-for-jsx-type\">\nUsing Dot Notation for JSX Type </h3> <p>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if <code>MyComponents.DatePicker</code> is a component, you can use it directly from JSX with:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\n\nconst MyComponents = {\n  DatePicker: function DatePicker(props) {\n    return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;;\n  }\n}\n\nfunction BlueDatePicker() {\n  return &lt;MyComponents.DatePicker color=\"blue\" /&gt;;\n}</pre>\n<h3 id=\"user-defined-components-must-be-capitalized\">\nUser-Defined Components Must Be Capitalized </h3> <p>When an element type starts with a lowercase letter, it refers to a built-in component like <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> and results in a string <code>'div'</code> or <code>'span'</code> passed to <code>React.createElement</code>. Types that start with a capital letter like <code>&lt;Foo /&gt;</code> compile to <code>React.createElement(Foo)</code> and correspond to a component defined or imported in your JavaScript file.</p> <p>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</p> <p>For example, this code will not run as expected:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\n\n// Wrong! This is a component and should have been capitalized:\nfunction hello(props) {\n  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:\n  return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;\n}\n\nfunction HelloWorld() {\n  // Wrong! React thinks &lt;hello /&gt; is an HTML tag because it's not capitalized:\n  return &lt;hello toWhat=\"World\" /&gt;;\n}</pre> <p>To fix this, we will rename <code>hello</code> to <code>Hello</code> and use <code>&lt;Hello /&gt;</code> when referring to it:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\n\n// Correct! This is a component and should be capitalized:\nfunction Hello(props) {\n  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:\n  return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;\n}\n\nfunction HelloWorld() {\n  // Correct! React knows &lt;Hello /&gt; is a component because it's capitalized.\n  return &lt;Hello toWhat=\"World\" /&gt;;\n}</pre>\n<h3 id=\"choosing-the-type-at-runtime\">\nChoosing the Type at Runtime </h3> <p>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\nimport { PhotoStory, VideoStory } from './stories';\n\nconst components = {\n  photo: PhotoStory,\n  video: VideoStory\n};\n\nfunction Story(props) {\n  // Wrong! JSX type can't be an expression.\n  return &lt;components[props.storyType] story={props.story} /&gt;;\n}</pre> <p>To fix this, we will assign the type to a capitalized variable first:</p> <pre class=\"highlight\" data-language=\"js\">import React from 'react';\nimport { PhotoStory, VideoStory } from './stories';\n\nconst components = {\n  photo: PhotoStory,\n  video: VideoStory\n};\n\nfunction Story(props) {\n  // Correct! JSX type can be a capitalized variable.\n  const SpecificStory = components[props.storyType];\n  return &lt;SpecificStory story={props.story} /&gt;;\n}</pre>\n<h2 id=\"props-in-jsx\">\nProps in JSX </h2> <p>There are several different ways to specify props in JSX.</p> <h3 id=\"javascript-expressions\">\nJavaScript Expressions </h3> <p>You can pass any JavaScript expression as a prop, by surrounding it with <code>{}</code>. For example, in this JSX:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</pre> <p>For <code>MyComponent</code>, the value of <code>props.foo</code> will be <code>10</code> because the expression <code>1 + 2 + 3 + 4</code> gets evaluated.</p> <p><code>if</code> statements and <code>for</code> loops are not expressions in JavaScript, so they can't be used in JSX directly. Instead, you can put these in the surrounding code. For example:</p> <pre class=\"highlight\" data-language=\"js\">function NumberDescriber(props) {\n  let description;\n  if (props.number % 2 == 0) {\n    description = &lt;strong&gt;even&lt;/strong&gt;;\n  } else {\n    description = &lt;i&gt;odd&lt;/i&gt;;\n  }\n  return &lt;div&gt;{props.number} is an {description} number&lt;/div&gt;;\n}</pre>\n<h3 id=\"string-literals\">\nString Literals </h3> <p>You can pass a string literal as a prop. These two JSX expressions are equivalent:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyComponent message=\"hello world\" /&gt;\n\n&lt;MyComponent message={'hello world'} /&gt;</pre> <p>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyComponent message=\"&amp;lt;3\" /&gt;\n\n&lt;MyComponent message={'&lt;3'} /&gt;</pre> <p>This behavior is usually not relevant. It's only mentioned here for completeness.</p> <h3 id=\"props-default-to-true\">\nProps Default to \"True\" </h3> <p>If you pass no value for a prop, it defaults to <code>true</code>. These two JSX expressions are equivalent:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyTextBox autocomplete /&gt;\n\n&lt;MyTextBox autocomplete={true} /&gt;</pre> <p>In general, we don't recommend using this because it can be confused with the <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015\">ES6 object shorthand</a> <code>{foo}</code> which is short for <code>{foo: foo}</code> rather than <code>{foo: true}</code>. This behavior is just there so that it matches the behavior of HTML.</p> <h3 id=\"spread-attributes\">\nSpread Attributes </h3> <p>If you already have <code>props</code> as an object, and you want to pass it in JSX, you can use <code>...</code> as a \"spread\" operator to pass the whole props object. These two components are equivalent:</p> <pre class=\"highlight\" data-language=\"js\">function App1() {\n  return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;\n}\n\nfunction App2() {\n  const props = {firstName: 'Ben', lastName: 'Hector'};\n  return &lt;Greeting {...props} /&gt;;\n}</pre> <p>Spread attributes can be useful when you are building generic containers. However, they can also make your code messy by making it easy to pass a lot of irrelevant props to components that don't care about them. We recommend that you use this syntax sparingly.</p> <h2 id=\"children-in-jsx\">\nChildren in JSX </h2> <p>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: <code>props.children</code>. There are several different ways to pass children:</p> <h3 id=\"string-literals\">\nString Literals </h3> <p>You can put a string between the opening and closing tags and <code>props.children</code> will just be that string. This is useful for many of the built-in HTML elements. For example:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</pre> <p>This is valid JSX, and <code>props.children</code> in <code>MyComponent</code> will simply be the string <code>\"Hello world!\"</code>. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</p> <pre class=\"highlight\" data-language=\"html\">&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt;</pre> <p>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div&gt;Hello World&lt;/div&gt;\n\n&lt;div&gt;\n  Hello World\n&lt;/div&gt;\n\n&lt;div&gt;\n  Hello\n  World\n&lt;/div&gt;\n\n&lt;div&gt;\n\n  Hello World\n&lt;/div&gt;</pre>\n<h3 id=\"jsx-children\">\nJSX Children </h3> <p>You can provide more JSX elements as the children. This is useful for displaying nested components:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyContainer&gt;\n  &lt;MyFirstComponent /&gt;\n  &lt;MySecondComponent /&gt;\n&lt;/MyContainer&gt;</pre> <p>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</p> <pre class=\"highlight\" data-language=\"html\">&lt;div&gt;\n  Here is a list:\n  &lt;ul&gt;\n    &lt;li&gt;Item 1&lt;/li&gt;\n    &lt;li&gt;Item 2&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <p>A React component can't return multiple React elements, but a single JSX expression can have multiple children, so if you want a component to render multiple things you can wrap it in a <code>div</code> like this.</p> <h3 id=\"javascript-expressions\">\nJavaScript Expressions </h3> <p>You can pass any JavaScript expression as children, by enclosing it within <code>{}</code>. For example, these expressions are equivalent:</p> <pre class=\"highlight\" data-language=\"js\">&lt;MyComponent&gt;foo&lt;/MyComponent&gt;\n\n&lt;MyComponent&gt;{'foo'}&lt;/MyComponent&gt;</pre> <p>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</p> <pre class=\"highlight\" data-language=\"js\">function Item(props) {\n  return &lt;li&gt;{props.message}&lt;/li&gt;;\n}\n\nfunction TodoList() {\n  const todos = ['finish doc', 'submit pr', 'nag dan to review'];\n  return (\n    &lt;ul&gt;\n      {todos.map((message) =&gt; &lt;Item key={message} message={message} /&gt;)}\n    &lt;/ul&gt;\n  );\n}</pre> <p>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</p> <pre class=\"highlight\" data-language=\"js\">function Hello(props) {\n  return &lt;div&gt;Hello {props.addressee}!&lt;/div&gt;;\n}</pre>\n<h3 id=\"functions-as-children\">\nFunctions as Children </h3> <p>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, <code>props.children</code> works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as <code>props.children</code>:</p> <pre class=\"highlight\" data-language=\"js\">// Calls the children callback numTimes to produce a repeated component\nfunction Repeat(props) {\n  let items = [];\n  for (let i = 0; i &lt; props.numTimes; i++) {\n    items.push(props.children(i));\n  }\n  return &lt;div&gt;{items}&lt;/div&gt;;\n}\n\nfunction ListOfTenThings() {\n  return (\n    &lt;Repeat numTimes={10}&gt;\n      {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}\n    &lt;/Repeat&gt;\n  );\n}</pre> <p>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</p> <h3 id=\"booleans-null-and-undefined-are-ignored\">\nBooleans, Null, and Undefined Are Ignored </h3> <p><code>false</code>, <code>null</code>, <code>undefined</code>, and <code>true</code> are valid children. They simply don't render. These JSX expressions will all render to the same thing:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div /&gt;\n\n&lt;div&gt;&lt;/div&gt;\n\n&lt;div&gt;{false}&lt;/div&gt;\n\n&lt;div&gt;{null}&lt;/div&gt;\n\n&lt;div&gt;{true}&lt;/div&gt;</pre> <p>This can be useful to conditionally render React elements. This JSX only renders a <code>&lt;Header /&gt;</code> if <code>showHeader</code> is <code>true</code>:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div&gt;\n  {showHeader &amp;&amp; &lt;Header /&gt;}\n  &lt;Content /&gt;\n&lt;/div&gt;</pre> <p>One caveat is that some <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Falsy\">\"falsy\" values</a>, such as the <code>0</code> number, are still rendered by React. For example, this code will not behave as you might expect because <code>0</code> will be printed when <code>props.messages</code> is an empty array:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div&gt;\n  {props.messages.length &amp;&amp;\n    &lt;MessageList messages={props.messages} /&gt;\n  }\n&lt;/div&gt;</pre> <p>To fix this, make sure that the expression before <code>&amp;&amp;</code> is always boolean:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div&gt;\n  {props.messages.length &gt; 0 &amp;&amp;\n    &lt;MessageList messages={props.messages} /&gt;\n  }\n&lt;/div&gt;</pre> <p>Conversely, if you want a value like <code>false</code>, <code>true</code>, <code>null</code>, or <code>undefined</code> to appear in the output, you have to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion\">convert it to a string</a> first:</p> <pre class=\"highlight\" data-language=\"js\">&lt;div&gt;\n  My JavaScript variable is {String(myVariable)}.\n&lt;/div&gt;</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/jsx-in-depth.html</a>\n  </p>\n</div>\n","react-without-es6":"<h1> React Without ES6 </h1>  <p>Normally you would define a React component as a plain JavaScript class:</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}</pre> <p>If you don't use ES6 yet, you may use the <code>React.createClass</code> helper instead:</p> <pre class=\"highlight\" data-language=\"javascript\">var Greeting = React.createClass({\n  render: function() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n});</pre> <p>The API of ES6 classes is similar to <code>React.createClass</code> with a few exceptions.</p> <h2 id=\"declaring-prop-types-and-default-props\">\nDeclaring Prop Types and Default Props </h2> <p>With functions and ES6 classes, <code>propTypes</code> and <code>defaultProps</code> are defined as properties on the components themselves:</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  // ...\n}\n\nGreeting.propTypes = {\n  name: React.PropTypes.string\n};\n\nGreeting.defaultProps = {\n  name: 'Mary'\n};</pre> <p>With <code>React.createClass()</code>, you need to define <code>propTypes</code> as a property on the passed object, and <code>getDefaultProps()</code> as a function on it:</p> <pre class=\"highlight\" data-language=\"javascript\">var Greeting = React.createClass({\n  propTypes: {\n    name: React.PropTypes.string\n  },\n\n  getDefaultProps: function() {\n    return {\n      name: 'Mary'\n    };\n  },\n\n  // ...\n\n});</pre>\n<h2 id=\"setting-the-initial-state\">\nSetting the Initial State </h2> <p>In ES6 classes, you can define the initial state by assigning <code>this.state</code> in the constructor:</p> <pre class=\"highlight\" data-language=\"javascript\">class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: props.initialCount};\n  }\n  // ...\n}</pre> <p>With <code>React.createClass()</code>, you have to provide a separate <code>getInitialState</code> method that returns the initial state:</p> <pre class=\"highlight\" data-language=\"javascript\">var Counter = React.createClass({\n  getInitialState: function() {\n    return {count: this.props.initialCount};\n  },\n  // ...\n});</pre>\n<h2 id=\"autobinding\">\nAutobinding </h2> <p>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don't automatically bind <code>this</code> to the instance. You'll have to explicitly use <code>.bind(this)</code> in the constructor:</p> <pre class=\"highlight\" data-language=\"javascript\">class SayHello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {message: 'Hello!'};\n    // This line is important!\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    alert(this.state.message);\n  }\n\n  render() {\n    // Because `this.handleClick` is bound, we can use it as an event handler.\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        Say hello\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>With <code>React.createClass()</code>, this is not necessary because it binds all methods:</p> <pre class=\"highlight\" data-language=\"javascript\">var SayHello = React.createClass({\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n\n  handleClick: function() {\n    alert(this.state.message);\n  },\n\n  render: function() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        Say hello\n      &lt;/button&gt;\n    );\n  }\n});</pre> <p>This means writing ES6 classes comes with a little more boilerplate code for event handlers, but the upside is slightly better performance in large applications.</p> <p>If the boilerplate code is too unattractive to you, you may enable the <strong>experimental</strong> <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\">Class Properties</a> syntax proposal with Babel:</p> <pre class=\"highlight\" data-language=\"javascript\">class SayHello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {message: 'Hello!'};\n  }\n  // WARNING: this syntax is experimental!\n  // Using an arrow here binds the method:\n  handleClick = () =&gt; {\n    alert(this.state.message);\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        Say hello\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>Please note that the syntax above is <strong>experimental</strong> and the syntax may change, or the proposal might not make it into the language.</p> <p>If you'd rather play it safe, you have a few options:</p> <ul> <li>Bind methods in the constructor.</li> <li>Use arrow functions, e.g. <code>onClick={(e) =&gt; this.handleClick(e)}</code>.</li> <li>Keep using <code>React.createClass()</code>.</li> </ul> <h2 id=\"mixins\">\nMixins </h2> <blockquote>  <p>ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.</p> <p><strong>We also found numerous issues in codebases using mixins, <a href=\"https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html\">and don't recommend using them in the new code</a>.</strong></p> <p>This section exists only for the reference.</p> </blockquote> <p>Sometimes very different components may share some common functionality. These are sometimes called <a href=\"https://en.wikipedia.org/wiki/Cross-cutting_concern\">cross-cutting concerns</a>. <a href=\"react-api#react.createclass\"><code>React.createClass</code></a> lets you use a legacy <code>mixins</code> system for that.</p> <p>One common use case is a component wanting to update itself on a time interval. It's easy to use <code>setInterval()</code>, but it's important to cancel your interval when you don't need it anymore to save memory. React provides <a href=\"refs-and-the-dom#component-lifecycle\">lifecycle methods</a> that let you know when a component is about to be created or destroyed. Let's create a simple mixin that uses these methods to provide an easy <code>setInterval()</code> function that will automatically get cleaned up when your component is destroyed.</p> <pre class=\"highlight\" data-language=\"javascript\">var SetIntervalMixin = {\n  componentWillMount: function() {\n    this.intervals = [];\n  },\n  setInterval: function() {\n    this.intervals.push(setInterval.apply(null, arguments));\n  },\n  componentWillUnmount: function() {\n    this.intervals.forEach(clearInterval);\n  }\n};\n\nvar TickTock = React.createClass({\n  mixins: [SetIntervalMixin], // Use the mixin\n  getInitialState: function() {\n    return {seconds: 0};\n  },\n  componentDidMount: function() {\n    this.setInterval(this.tick, 1000); // Call a method on the mixin\n  },\n  tick: function() {\n    this.setState({seconds: this.state.seconds + 1});\n  },\n  render: function() {\n    return (\n      &lt;p&gt;\n        React has been running for {this.state.seconds} seconds.\n      &lt;/p&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;TickTock /&gt;,\n  document.getElementById('example')\n);</pre> <p>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-without-es6.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-without-es6.html</a>\n  </p>\n</div>\n","react-dom":"<h1> ReactDOM </h1>  <p>If you use React as a script tag, these top-level APIs are available on the <code>ReactDOM</code> global. If you use ES6 with npm, you can write <code>import ReactDOM from 'react-dom'</code>. If you use ES5 with npm, you can write <code>var ReactDOM = require('react-dom')</code>.</p> <h2 id=\"overview\">\nOverview </h2> <p>The <code>react-dom</code> package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</p> <ul> <li><a href=\"#render\"><code>render()</code></a></li> <li><a href=\"#unmountcomponentatnode\"><code>unmountComponentAtNode()</code></a></li> <li><a href=\"#finddomnode\"><code>findDOMNode()</code></a></li> </ul> <h3 id=\"browser-support\">\nBrowser Support </h3> <p>React supports all popular browsers, including Internet Explorer 9 and above.</p> <blockquote> <p>Note</p> <p>We don't support older browsers that don't support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as <a href=\"https://github.com/es-shims/es5-shim\">es5-shim and es5-sham</a> are included in the page. You're on your own if you choose to take this path.</p> </blockquote>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"render\">\n<code>render()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactDOM.render(\n  element,\n  container,\n  [callback]\n)</pre> <p>Render a React element into the DOM in the supplied <code>container</code> and return a <a href=\"refs-and-the-dom\">reference</a> to the component (or returns <code>null</code> for <a href=\"components-and-props#functional-and-class-components\">stateless components</a>).</p> <p>If the React element was previously rendered into <code>container</code>, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</p> <p>If the optional callback is provided, it will be executed after the component is rendered or updated.</p> <blockquote>  <p><code>ReactDOM.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.</p> <p><code>ReactDOM.render()</code> does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.</p> <p><code>ReactDOM.render()</code> currently returns a reference to the root <code>ReactComponent</code> instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root <code>ReactComponent</code> instance, the preferred solution is to attach a <a href=\"refs-and-the-dom#the-ref-callback-attribute\">callback ref</a> to the root element.</p> </blockquote>  <h3 id=\"unmountcomponentatnode\">\n<code>unmountComponentAtNode()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactDOM.unmountComponentAtNode(container)</pre> <p>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns <code>true</code> if a component was unmounted and <code>false</code> if there was no component to unmount.</p>  <h3 id=\"finddomnode\">\n<code>findDOMNode()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactDOM.findDOMNode(component)</pre> <p>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. <strong>In most cases, you can attach a ref to the DOM node and avoid using <code>findDOMNode</code> at all.</strong> When <code>render</code> returns <code>null</code> or <code>false</code>, <code>findDOMNode</code> returns <code>null</code>.</p> <blockquote>  <p><code>findDOMNode</code> is an escape hatch used to access the underlying DOM node. In most cases, use of this escape hatch is discouraged because it pierces the component abstraction.</p> <p><code>findDOMNode</code> only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling <code>findDOMNode()</code> in <code>render()</code> on a component that has yet to be created) an exception will be thrown.</p> <p><code>findDOMNode</code> cannot be used on functional components.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-dom.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-dom.html</a>\n  </p>\n</div>\n","react-dom-server":"<h1> ReactDOMServer </h1>  <p>If you use React as a script tag, these top-level APIs are available on the <code>ReactDOMServer</code> global. If you use ES6 with npm, you can write <code>import ReactDOMServer from 'react-dom/server'</code>. If you use ES5 with npm, you can write <code>var ReactDOMServer = require('react-dom/server')</code>.</p> <h2 id=\"overview\">\nOverview </h2> <p>The <code>ReactDOMServer</code> class allows you to render your components on the server.</p> <ul> <li><a href=\"#rendertostring\"><code>renderToString()</code></a></li> <li><a href=\"#rendertostaticmarkup\"><code>renderToStaticMarkup()</code></a></li> </ul>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"rendertostring\">\n<code>renderToString()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactDOMServer.renderToString(element)</pre> <p>Render a React element to its initial HTML. This should only be used on the server. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</p> <p>If you call <a href=\"react-dom#render\"><code>ReactDOM.render()</code></a> on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</p>  <h3 id=\"rendertostaticmarkup\">\n<code>renderToStaticMarkup()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactDOMServer.renderToStaticMarkup(element)</pre> <p>Similar to <a href=\"#rendertostring\"><code>renderToString</code></a>, except this doesn't create extra DOM attributes such as <code>data-reactid</code>, that React uses internally. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save lots of bytes.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-dom-server.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-dom-server.html</a>\n  </p>\n</div>\n","lists-and-keys":"<h1> Lists and Keys </h1>  <p>First, let's review how you transform lists in JavaScript.</p> <p>Given the code below, we use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>map()</code></a> function to take an array of <code>numbers</code> and double their values. We assign the new array returned by <code>map()</code> to the variable <code>doubled</code> and log it:</p> <pre class=\"highlight\" data-language=\"javascript\">const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((number) =&gt; number * 2);\nconsole.log(doubled);</pre> <p>This code logs <code>[2, 4, 6, 8, 10]</code> to the console.</p> <p>In React, transforming arrays into lists of <a href=\"rendering-elements\">elements</a> is nearly identical.</p> <h3 id=\"rendering-multiple-components\">\nRendering Multiple Components </h3> <p>You can build collections of elements and <a href=\"introducing-jsx#embedding-expressions-in-jsx\">include them in JSX</a> using curly braces <code>{}</code>.</p> <p>Below, we loop through the <code>numbers</code> array using the Javascript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>map()</code></a> function. We return an <code>&lt;li&gt;</code> element for each item. Finally, we assign the resulting array of elements to <code>listItems</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =&gt;\n  &lt;li&gt;{number}&lt;/li&gt;\n);</pre> <p>We include the entire <code>listItems</code> array inside a <code>&lt;ul&gt;</code> element, and <a href=\"rendering-elements#rendering-an-element-into-the-dom\">render it to the DOM</a>:</p> <pre class=\"highlight\" data-language=\"javascript\">ReactDOM.render(\n  &lt;ul&gt;{listItems}&lt;/ul&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/GjPyQr?editors=0011\">Try it on CodePen.</a></p> <p>This code displays a bullet list of numbers between 1 and 5.</p> <h3 id=\"basic-list-component\">\nBasic List Component </h3> <p>Usually you would render lists inside a <a href=\"components-and-props\">component</a>.</p> <p>We can refactor the previous example into a component that accepts an array of <code>numbers</code> and outputs an unordered list of elements.</p> <pre class=\"highlight\" data-language=\"javascript\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    &lt;li&gt;{number}&lt;/li&gt;\n  );\n  return (\n    &lt;ul&gt;{listItems}&lt;/ul&gt;\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById('root')\n);</pre> <p>When you run this code, you'll be given a warning that a key should be provided for list items. A \"key\" is a special string attribute you need to include when creating lists of elements. We'll discuss why it's important in the next section.</p> <p>Let's assign a <code>key</code> to our list items inside <code>numbers.map()</code> and fix the missing key issue.</p> <pre class=\"highlight\" data-language=\"javascript\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    &lt;li key={number.toString()}&gt;\n      {number}\n    &lt;/li&gt;\n  );\n  return (\n    &lt;ul&gt;{listItems}&lt;/ul&gt;\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/jrXYRR?editors=0011\">Try it on CodePen.</a></p> <h2 id=\"keys\">\nKeys </h2> <p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</p> <pre class=\"highlight\" data-language=\"js\">const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =&gt;\n  &lt;li key={number.toString()}&gt;\n    {number}\n  &lt;/li&gt;\n);</pre> <p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</p> <pre class=\"highlight\" data-language=\"js\">const todoItems = todos.map((todo) =&gt;\n  &lt;li key={todo.id}&gt;\n    {todo.text}\n  &lt;/li&gt;\n);</pre> <p>When you don't have stable IDs for rendered items, you may use the item index as a key as a last resort:</p> <pre class=\"highlight\" data-language=\"js\">const todoItems = todos.map((todo, index) =&gt;\n  // Only do this if items have no stable IDs\n  &lt;li key={index}&gt;\n    {todo.text}\n  &lt;/li&gt;\n);</pre> <p>We don't recommend using indexes for keys if the items can reorder, as that would be slow. You may read an <a href=\"reconciliation#recursing-on-children\">in-depth explanation about why keys are necessary</a> if you're interested.</p> <h3 id=\"extracting-components-with-keys\">\nExtracting Components with Keys </h3> <p>Keys only make sense in the context of the surrounding array.</p> <p>For example, if you <a href=\"components-and-props#extracting-components\">extract</a> a <code>ListItem</code> component, you should keep the key on the <code>&lt;ListItem /&gt;</code> elements in the array rather than on the root <code>&lt;li&gt;</code> element in the <code>ListItem</code> itself.</p> <p><strong>Example: Incorrect Key Usage</strong></p> <pre class=\"highlight\" data-language=\"javascript\">function ListItem(props) {\n  const value = props.value;\n  return (\n    // Wrong! There is no need to specify the key here:\n    &lt;li key={value.toString()}&gt;\n      {value}\n    &lt;/li&gt;\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    // Wrong! The key should have been specified here:\n    &lt;ListItem value={number} /&gt;\n  );\n  return (\n    &lt;ul&gt;\n      {listItems}\n    &lt;/ul&gt;\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById('root')\n);</pre> <p><strong>Example: Correct Key Usage</strong></p> <pre class=\"highlight\" data-language=\"javascript\">function ListItem(props) {\n  // Correct! There is no need to specify the key here:\n  return &lt;li&gt;{props.value}&lt;/li&gt;;\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    // Correct! Key should be specified inside the array.\n    &lt;ListItem key={number.toString()}\n              value={number} /&gt;\n  );\n  return (\n    &lt;ul&gt;\n      {listItems}\n    &lt;/ul&gt;\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/rthor/pen/QKzJKG?editors=0010\">Try it on CodePen.</a></p> <p>A good rule of thumb is that elements inside the <code>map()</code> call need keys.</p> <h3 id=\"keys-must-only-be-unique-among-siblings\">\nKeys Must Only Be Unique Among Siblings </h3> <p>Keys used within arrays should be unique among their siblings. However they don't need to be globally unique. We can use the same keys when we produce two different arrays:</p> <pre class=\"highlight\" data-language=\"js\">function Blog(props) {\n  const sidebar = (\n    &lt;ul&gt;\n      {props.posts.map((post) =&gt;\n        &lt;li key={post.id}&gt;\n          {post.title}\n        &lt;/li&gt;\n      )}\n    &lt;/ul&gt;\n  );\n  const content = props.posts.map((post) =&gt;\n    &lt;div key={post.id}&gt;\n      &lt;h3&gt;{post.title}&lt;/h3&gt;\n      &lt;p&gt;{post.content}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n  return (\n    &lt;div&gt;\n      {sidebar}\n      &lt;hr /&gt;\n      {content}\n    &lt;/div&gt;\n  );\n}\n\nconst posts = [\n  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},\n  {id: 2, title: 'Installation', content: 'You can install React from npm.'}\n];\nReactDOM.render(\n  &lt;Blog posts={posts} /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/NRZYGN?editors=0010\">Try it on CodePen.</a></p> <p>Keys serve as a hint to React but they don't get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</p> <pre class=\"highlight\" data-language=\"js\">const content = posts.map((post) =&gt;\n  &lt;Post\n    key={post.id}\n    id={post.id}\n    title={post.title} /&gt;\n);</pre> <p>With the example above, the <code>Post</code> component can read <code>props.id</code>, but not <code>props.key</code>.</p> <h3 id=\"embedding-map-in-jsx\">\nEmbedding map() in JSX </h3> <p>In the examples above we declared a separate <code>listItems</code> variable and included it in JSX:</p> <pre class=\"highlight\" data-language=\"js\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt;\n    &lt;ListItem key={number.toString()}\n              value={number} /&gt;\n  );\n  return (\n    &lt;ul&gt;\n      {listItems}\n    &lt;/ul&gt;\n  );\n}</pre> <p>JSX allows <a href=\"introducing-jsx#embedding-expressions-in-jsx\">embedding any expressions</a> in curly braces so we could inline the <code>map()</code> result:</p> <pre class=\"highlight\" data-language=\"js\">function NumberList(props) {\n  const numbers = props.numbers;\n  return (\n    &lt;ul&gt;\n      {numbers.map((number) =&gt;\n        &lt;ListItem key={number.toString()}\n                  value={number} /&gt;\n      )}\n    &lt;/ul&gt;\n  );\n}</pre> <p><a href=\"https://codepen.io/gaearon/pen/BLvYrB?editors=0010\">Try it on CodePen.</a></p> <p>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the <code>map()</code> body is too nested, it might be a good time to <a href=\"components-and-props#extracting-components\">extract a component</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/lists-and-keys.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/lists-and-keys.html</a>\n  </p>\n</div>\n","forms":"<h1> Forms </h1>  <p>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</p> <pre class=\"highlight\" data-language=\"html\">&lt;form&gt;\n  &lt;label&gt;\n    Name:\n    &lt;input type=\"text\" name=\"name\" /&gt;\n  &lt;/label&gt;\n  &lt;input type=\"submit\" value=\"Submit\" /&gt;\n&lt;/form&gt;</pre> <p>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it's convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called \"controlled components\".</p> <h2 id=\"controlled-components\">\nControlled Components </h2> <p>In HTML, form elements such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with <a href=\"react-component#setstate\"><code>setState()</code></a>.</p> <p>We can combine the two by making the React state be the \"single source of truth\". Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a \"controlled component\".</p> <p>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</p> <pre class=\"highlight\" data-language=\"javascript\">class NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Name:\n          &lt;input type=\"text\" value={this.state.value} onChange={this.handleChange} /&gt;\n        &lt;/label&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</pre> <p><a href=\"https://codepen.io/gaearon/pen/VmmPgp?editors=0010\">Try it on CodePen.</a></p> <p>Since the <code>value</code> attribute is set on our form element, the displayed value will always be <code>this.state.value</code>, making the React state the source of truth. Since <code>handleChange</code> runs on every keystroke to update the React state, the displayed value will update as the user types.</p> <p>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write <code>handleChange</code> as:</p> <pre class=\"highlight\" data-language=\"javascript\">handleChange(event) {\n  this.setState({value: event.target.value.toUpperCase()});\n}</pre>\n<h2 id=\"the-textarea-tag\">\nThe textarea Tag </h2> <p>In HTML, a <code>&lt;textarea&gt;</code> element defines its text by its children:</p> <pre class=\"highlight\" data-language=\"html\">&lt;textarea&gt;\n  Hello there, this is some text in a text area\n&lt;/textarea&gt;</pre> <p>In React, a <code>&lt;textarea&gt;</code> uses a <code>value</code> attribute instead. This way, a form using a <code>&lt;textarea&gt;</code> can be written very similarly to a form that uses a single-line input:</p> <pre class=\"highlight\" data-language=\"javascript\">class EssayForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: 'Please write an essay about your favorite DOM element.'\n    };\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('An essay was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Name:\n          &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;\n        &lt;/label&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</pre> <p>Notice that <code>this.state.value</code> is initialized in the constructor, so that the text area starts off with some text in it.</p> <h2 id=\"the-select-tag\">\nThe select Tag </h2> <p>In HTML, <code>&lt;select&gt;</code> creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</p> <pre class=\"highlight\" data-language=\"html\">&lt;select&gt;\n  &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt;\n  &lt;option value=\"lime\"&gt;Lime&lt;/option&gt;\n  &lt;option selected value=\"coconut\"&gt;Coconut&lt;/option&gt;\n  &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;\n&lt;/select&gt;</pre> <p>Note that the Coconut option is initially selected, because of the <code>selected</code> attribute. React, instead of using this <code>selected</code> attribute, uses a <code>value</code> attribute on the root <code>select</code> tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</p> <pre class=\"highlight\" data-language=\"javascript\">class FlavorForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: 'coconut'};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('Your favorite flavor is: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Pick your favorite La Croix flavor:\n          &lt;select value={this.state.value} onChange={this.handleChange}&gt;\n            &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt;\n            &lt;option value=\"lime\"&gt;Lime&lt;/option&gt;\n            &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt;\n            &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/label&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</pre> <p><a href=\"https://codepen.io/gaearon/pen/JbbEzX?editors=0010\">Try it on CodePen.</a></p> <p>Overall, this makes it so that <code>&lt;input type=\"text\"&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> all work very similarly - they all accept a <code>value</code> attribute that you can use to implement a controlled component.</p> <h2 id=\"alternatives-to-controlled-components\">\nAlternatives to Controlled Components </h2> <p>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out <a href=\"uncontrolled-components\">uncontrolled components</a>, an alternative technique for implementing input forms.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/forms.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/forms.html</a>\n  </p>\n</div>\n","uncontrolled-components":"<h1> Uncontrolled Components </h1>  <p>In most cases, we recommend using <a href=\"forms\">controlled components</a> to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</p> <p>To write an uncontrolled component, instead of writing an event handler for every state update, you can <a href=\"refs-and-the-dom\">use a ref</a> to get form values from the DOM.</p> <p>For example, this code accepts a single name in an uncontrolled component:</p> <pre class=\"highlight\" data-language=\"javascript\">class NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Name:\n          &lt;input type=\"text\" ref={(input) =&gt; this.input = input} /&gt;\n        &lt;/label&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</pre> <p><a href=\"https://codepen.io/gaearon/pen/WooRWa?editors=0010\">Try it on CodePen.</a></p> <p>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</p> <p>If it's still not clear which type of component you should use for a particular situation, you might find <a href=\"http://goshakkk.name/controlled-vs-uncontrolled-inputs-react/\">this article on controlled versus uncontrolled inputs</a> to be helpful.</p> <h3 id=\"default-values\">\nDefault Values </h3> <p>In the React rendering lifecycle, the <code>value</code> attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a <code>defaultValue</code> attribute instead of <code>value</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">render() {\n  return (\n    &lt;form onSubmit={this.handleSubmit}&gt;\n      &lt;label&gt;\n        Name:\n        &lt;input\n          defaultValue=\"Bob\"\n          type=\"text\"\n          ref={(input) =&gt; this.input = input} /&gt;\n      &lt;/label&gt;\n      &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n  );\n}</pre> <p>Likewise, <code>&lt;input type=\"checkbox\"&gt;</code> and <code>&lt;input type=\"radio\"&gt;</code> support <code>defaultChecked</code>, and <code>&lt;select&gt;</code> supports <code>defaultValue</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/uncontrolled-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/uncontrolled-components.html</a>\n  </p>\n</div>\n","react-api":"<h1> React Top-Level API </h1>  <p><code>React</code> is the entry point to the React library. If you use React as a script tag, these top-level APIs are available on the <code>React</code> global. If you use ES6 with npm, you can write <code>import React from 'react'</code>. If you use ES5 with npm, you can write <code>var React = require('react')</code>.</p> <h2 id=\"overview\">\nOverview </h2>\n<h3 id=\"components\">\nComponents </h3> <p>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing <code>React.Component</code> or <code>React.PureComponent</code>.</p> <ul> <li><a href=\"#react.component\"><code>React.Component</code></a></li> <li><a href=\"#react.purecomponent\"><code>React.PureComponent</code></a></li> </ul> <p>If you don't use ES6 classes, you may use this helper instead.</p> <ul> <li><a href=\"#createclass\"><code>createClass()</code></a></li> </ul> <h3 id=\"creating-react-elements\">\nCreating React Elements </h3> <p>We recommend <a href=\"introducing-jsx\">using JSX</a> to describe what your UI should look like. Each JSX element is just syntactic sugar for calling <a href=\"#createelement\"><code>React.createElement()</code></a>. You will not typically invoke the following methods directly if you are using JSX.</p> <ul> <li><a href=\"#createelement\"><code>createElement()</code></a></li> <li><a href=\"#createfactory\"><code>createFactory()</code></a></li> </ul> <p>See <a href=\"react-without-jsx\">Using React without JSX</a> for more information.</p> <h3 id=\"transforming-elements\">\nTransforming Elements </h3> <p><code>React</code> also provides some other APIs:</p> <ul> <li><a href=\"#cloneelement\"><code>cloneElement()</code></a></li> <li><a href=\"#isvalidelement\"><code>isValidElement()</code></a></li> <li><a href=\"#react.children\"><code>React.Children</code></a></li> </ul> <h3 id=\"typechecking-with-proptypes\">\nTypechecking with PropTypes </h3> <p>You can use <code>React.PropTypes</code> to run typechecking on the props for a component.</p> <ul> <li><a href=\"#react.proptypes\"><code>React.PropTypes</code></a></li> <li><a href=\"#react.proptypes.array\"><code>React.PropTypes.array</code></a></li> <li><a href=\"#react.proptypes.bool\"><code>React.PropTypes.bool</code></a></li> <li><a href=\"#react.proptypes.func\"><code>React.PropTypes.func</code></a></li> <li><a href=\"#react.proptypes.number\"><code>React.PropTypes.number</code></a></li> <li><a href=\"#react.proptypes.object\"><code>React.PropTypes.object</code></a></li> <li><a href=\"#react.proptypes.string\"><code>React.PropTypes.string</code></a></li> <li><a href=\"#react.proptypes.symbol\"><code>React.PropTypes.symbol</code></a></li> <li><a href=\"#react.proptypes.node\"><code>React.PropTypes.node</code></a></li> <li><a href=\"#react.proptypes.element\"><code>React.PropTypes.element</code></a></li> <li><a href=\"#react.proptypes.instanceof\"><code>React.PropTypes.instanceOf()</code></a></li> <li><a href=\"#react.proptypes.oneof\"><code>React.PropTypes.oneOf()</code></a></li> <li><a href=\"#react.proptypes.oneoftype\"><code>React.PropTypes.oneOfType()</code></a></li> <li><a href=\"#react.proptypes.arrayof\"><code>React.PropTypes.arrayOf()</code></a></li> <li><a href=\"#react.proptypes.objectof\"><code>React.PropTypes.objectOf()</code></a></li> <li><a href=\"#react.proptypes.shape\"><code>React.PropTypes.shape()</code></a></li> <li><a href=\"#react.proptypes.any\"><code>React.PropTypes.any</code></a></li> </ul> <p>Validators treat props as optional by default. You can use <code>isRequired</code> to make sure a warning is shown if the prop is not provided.</p> <ul> <li><a href=\"#isrequired\"><code>isRequired</code></a></li> </ul> <h3 id=\"add-ons\">\nAdd-Ons </h3> <p>If you're using <a href=\"addons\"><code>react-with-addons.js</code></a>, the React Add-Ons will be available via <code>React.addons</code>.</p> <ul> <li><a href=\"#react.addons\"><code>React.addons</code></a></li> </ul>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"react.component\">\n<code>React.Component</code> </h3> <p><code>React.Component</code> is the base class for React components when they are defined using <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 classes</a>.</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}</pre> <p>See the <a href=\"react-component\">React.Component API Reference</a> for a list of methods and properties related to the base <code>React.Component</code> class.</p>  <h3 id=\"react.purecomponent\">\n<code>React.PureComponent</code> </h3> <p><code>React.PureComponent</code> is exactly like <a href=\"#react.component\"><code>React.Component</code></a> but implements <a href=\"react-component#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a> with a shallow prop and state comparison.</p> <p>If your React component's <code>render()</code> function renders the same result given the same props and state, you can use <code>React.PureComponent</code> for a performance boost in some cases.</p> <blockquote> <p>Note</p> <p><code>React.PureComponent</code>'s <code>shouldComponentUpdate()</code> only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend <code>PureComponent</code> when you expect to have simple props and state, or use <a href=\"react-component#forceupdate\"><code>forceUpdate()</code></a> when you know deep data structures have changed. Or, consider using <a href=\"https://facebook.github.io/immutable-js/\">immutable objects</a> to facilitate fast comparisons of nested data.</p> <p>Furthermore, <code>React.PureComponent</code>'s <code>shouldComponentUpdate()</code> skips prop updates for the whole component subtree. Make sure all the children components are also \"pure\".</p> </blockquote>  <h3 id=\"createclass\">\n<code>createClass()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">React.createClass(specification)</pre> <p>If you don't use ES6 yet, you may use the <code>React.createClass()</code> helper instead to create a component class.</p> <pre class=\"highlight\" data-language=\"javascript\">var Greeting = React.createClass({\n  render: function() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n});</pre> <p>See <a href=\"react-without-es6\">Using React without ES6</a> for more information.</p>  <h3 id=\"createelement\">\n<code>createElement()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">React.createElement(\n  type,\n  [props],\n  [...children]\n)</pre> <p>Create and return a new <a href=\"rendering-elements\">React element</a> of the given type. The type argument can be either a tag name string (such as <code>'div'</code> or <code>'span'</code>), or a <a href=\"components-and-props\">React component</a> type (a class or a function).</p> <p>Convenience wrappers around <code>React.createElement()</code> for DOM components are provided by <code>React.DOM</code>. For example, <code>React.DOM.a(...)</code> is a convenience wrapper for <code>React.createElement('a', ...)</code>. They are considered legacy, and we encourage you to either use JSX or use <code>React.createElement()</code> directly instead.</p> <p>Code written with <a href=\"introducing-jsx\">JSX</a> will be converted to use <code>React.createElement()</code>. You will not typically invoke <code>React.createElement()</code> directly if you are using JSX. See <a href=\"react-without-jsx\">React Without JSX</a> to learn more.</p>  <h3 id=\"cloneelement\">\n<code>cloneElement()</code> </h3>\n<pre class=\"highlight\" data-language=\"text\">React.cloneElement(\n  element,\n  [props],\n  [...children]\n)</pre> <p>Clone and return a new React element using <code>element</code> as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. <code>key</code> and <code>ref</code> from the original element will be preserved.</p> <p><code>React.cloneElement()</code> is almost equivalent to:</p> <pre class=\"highlight\" data-language=\"js\">&lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt;</pre> <p>However, it also preserves <code>ref</code>s. This means that if you get a child with a <code>ref</code> on it, you won't accidentally steal it from your ancestor. You will get the same <code>ref</code> attached to your new element.</p> <p>This API was introduced as a replacement of the deprecated <code>React.addons.cloneWithProps()</code>.</p>  <h3 id=\"createfactory\">\n<code>createFactory()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">React.createFactory(type)</pre> <p>Return a function that produces React elements of a given type. Like <a href=\"#createElement\"><code>React.createElement()</code></a>, the type argument can be either a tag name string (such as <code>'div'</code> or <code>'span'</code>), or a <a href=\"components-and-props\">React component</a> type (a class or a function).</p> <p>This helper is considered legacy, and we encourage you to either use JSX or use <code>React.createElement()</code> directly instead.</p> <p>You will not typically invoke <code>React.createFactory()</code> directly if you are using JSX. See <a href=\"react-without-jsx\">React Without JSX</a> to learn more.</p>  <h3 id=\"isvalidelement\">\n<code>isValidElement()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">React.isValidElement(object)</pre> <p>Verifies the object is a React element. Returns <code>true</code> or <code>false</code>.</p>  <h3 id=\"react.children\">\n<code>React.Children</code> </h3> <p><code>React.Children</code> provides utilities for dealing with the <code>this.props.children</code> opaque data structure.</p> <h4 id=\"react.children.map\">\n<code>React.Children.map</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.map(children, function[(thisArg)])</pre> <p>Invokes a function on every immediate child contained within <code>children</code> with <code>this</code> set to <code>thisArg</code>. If <code>children</code> is a keyed fragment or array it will be traversed: the function will never be passed the container objects. If children is <code>null</code> or <code>undefined</code>, returns <code>null</code> or <code>undefined</code> rather than an array.</p> <h4 id=\"react.children.foreach\">\n<code>React.Children.forEach</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.forEach(children, function[(thisArg)])</pre> <p>Like <a href=\"#react.children.map\"><code>React.Children.map()</code></a> but does not return an array.</p> <h4 id=\"react.children.count\">\n<code>React.Children.count</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.count(children)</pre> <p>Returns the total number of components in <code>children</code>, equal to the number of times that a callback passed to <code>map</code> or <code>forEach</code> would be invoked.</p> <h4 id=\"react.children.only\">\n<code>React.Children.only</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.only(children)</pre> <p>Returns the only child in <code>children</code>. Throws otherwise.</p> <h4 id=\"react.children.toarray\">\n<code>React.Children.toArray</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.toArray(children)</pre> <p>Returns the <code>children</code> opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice <code>this.props.children</code> before passing it down.</p> <blockquote>  <p><code>React.Children.toArray()</code> changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, <code>toArray</code> prefixes each key in the returned array so that each element's key is scoped to the input array containing it.</p> </blockquote>  <h3 id=\"react.proptypes\">\n<code>React.PropTypes</code> </h3> <p><code>React.PropTypes</code> exports a range of validators that can be used with a component's <code>propTypes</code> object to validate props being passed to your components.</p> <p>For more information about <code>PropTypes</code>, see <a href=\"typechecking-with-proptypes\">Typechecking with PropTypes</a>.</p> <h4 id=\"react.proptypes.array\">\n<code>React.PropTypes.array</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.array</pre> <p>Validates that a prop is a JavaScript array primitive.</p> <h4 id=\"react.proptypes.bool\">\n<code>React.PropTypes.bool</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.bool</pre> <p>Validates that a prop is a JavaScript bool primitive.</p> <h4 id=\"react.proptypes.func\">\n<code>React.PropTypes.func</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.func</pre> <p>Validates that a prop is a JavaScript function.</p> <h4 id=\"react.proptypes.number\">\n<code>React.PropTypes.number</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.number</pre> <p>Validates that a prop is a JavaScript number primitive.</p> <h4 id=\"react.proptypes.object\">\n<code>React.PropTypes.object</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.object</pre> <p>Validates that a prop is a JavaScript object.</p> <h4 id=\"react.proptypes.string\">\n<code>React.PropTypes.string</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.string</pre> <p>Validates that a prop is a JavaScript string primitive.</p> <h4 id=\"react.proptypes.symbol\">\n<code>React.PropTypes.symbol</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.symbol</pre> <p>Validates that a prop is a JavaScript symbol.</p> <h4 id=\"react.proptypes.node\">\n<code>React.PropTypes.node</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.node</pre> <p>Validates that a prop is anything that can be rendered: numbers, strings, elements or an array (or fragment) containing these types.</p> <h4 id=\"react.proptypes.element\">\n<code>React.PropTypes.element</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.element</pre> <p>Validates that a prop is a React element.</p> <h4 id=\"react.proptypes.instanceof\">\n<code>React.PropTypes.instanceOf()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.instanceOf(class)</pre> <p>Validates that a prop is an instance of a class. This uses JavaScript's <code>instanceof</code> operator.</p> <h4 id=\"react.proptypes.oneof\">\n<code>React.PropTypes.oneOf()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.oneOf(arrayOfValues)</pre> <p>Validates that a prop is limited to specific values by treating it as an enum.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\n}</pre>\n<h4 id=\"react.proptypes.oneoftype\">\n<code>React.PropTypes.oneOfType()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.oneOfType(arrayOfPropTypes)</pre> <p>Validates that a prop is an object that could be one of many types.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  optionalUnion: React.PropTypes.oneOfType([\n    React.PropTypes.string,\n    React.PropTypes.number,\n    React.PropTypes.instanceOf(Message)\n  ]),\n}</pre>\n<h4 id=\"react.proptypes.arrayof\">\n<code>React.PropTypes.arrayOf()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.arrayOf(propType)</pre> <p>Validates that a prop is an an array of a certain type.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\n}</pre>\n<h4 id=\"react.proptypes.objectof\">\n<code>React.PropTypes.objectOf()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.objectOf(propType)</pre> <p>Validates that a prop is an object with property values of a certain type.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\n}</pre>\n<h4 id=\"react.proptypes.shape\">\n<code>React.PropTypes.shape()</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.shape(object)</pre> <p>Validates that a prop is an object taking on a particular shape.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  optionalObjectWithShape: React.PropTypes.shape({\n    color: React.PropTypes.string,\n    fontSize: React.PropTypes.number\n  }),\n}</pre>\n<h4 id=\"react.proptypes.any\">\n<code>React.PropTypes.any</code> </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.PropTypes.any</pre> <p>Validates that a prop has a value of any data type. Usually followed by <code>isRequired</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  requiredAny: React.PropTypes.any.isRequired,\n}</pre>\n<h3 id=\"isrequired\">\n<code>isRequired</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">propType.isRequired</pre> <p>You can chain any of the above validators with <code>isRequired</code> to make sure a warning is shown if the prop is not provided.</p> <pre class=\"highlight\" data-language=\"javascript\">MyComponent.propTypes = {\n  requiredFunc: React.PropTypes.func.isRequired,\n}</pre>  <h3 id=\"react.addons\">\n<code>React.addons</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">React.addons</pre> <p><code>React.addons</code> exports a range of add-ons when using <a href=\"addons\"><code>react-with-addons.js</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-api.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-api.html</a>\n  </p>\n</div>\n","dom-elements":"<h1> DOM Elements </h1>  <p>React implements a browser-independent DOM system for performance and cross-browser compatibility. We took the opportunity to clean up a few rough edges in browser DOM implementations.</p> <p>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute <code>tabindex</code> corresponds to the attribute <code>tabIndex</code> in React. The exception is <code>aria-*</code> and <code>data-*</code> attributes, which should be lowercased.</p> <h2 id=\"differences-in-attributes\">\nDifferences In Attributes </h2> <p>There are a number of attributes that work differently between React and HTML:</p> <h3 id=\"checked\">\nchecked </h3> <p>The <code>checked</code> attribute is supported by <code>&lt;input&gt;</code> components of type <code>checkbox</code> or <code>radio</code>. You can use it to set whether the component is checked. This is useful for building controlled components. <code>defaultChecked</code> is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.</p> <h3 id=\"classname\">\nclassName </h3> <p>To specify a CSS class, use the <code>className</code> attribute. This applies to all regular DOM and SVG elements like <code>&lt;div&gt;</code>, <code>&lt;a&gt;</code>, and others.</p> <p>If you use React with Web Components (which is uncommon), use the <code>class</code> attribute instead.</p> <h3 id=\"dangerouslysetinnerhtml\">\ndangerouslySetInnerHTML </h3> <p><code>dangerouslySetInnerHTML</code> is React's replacement for using <code>innerHTML</code> in the browser DOM. In general, setting HTML from code is risky because it's easy to inadvertently expose your users to a <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">cross-site scripting (XSS)</a> attack. So, you can set HTML directly from React, but you have to type out <code>dangerouslySetInnerHTML</code> and pass an object with a <code>__html</code> key, to remind yourself that it's dangerous. For example:</p> <pre class=\"highlight\" data-language=\"js\">function createMarkup() {\n  return {__html: 'First &amp;middot; Second'};\n}\n\nfunction MyComponent() {\n  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;\n}</pre>\n<h3 id=\"htmlfor\">\nhtmlFor </h3> <p>Since <code>for</code> is a reserved word in JavaScript, React elements use <code>htmlFor</code> instead.</p> <h3 id=\"onchange\">\nonChange </h3> <p>The <code>onChange</code> event behaves as you would expect it to: whenever a form field is changed, this event is fired. We intentionally do not use the existing browser behavior because <code>onChange</code> is a misnomer for its behavior and React relies on this event to handle user input in real time.</p> <h3 id=\"selected\">\nselected </h3> <p>The <code>selected</code> attribute is supported by <code>&lt;option&gt;</code> components. You can use it to set whether the component is selected. This is useful for building controlled components.</p> <h3 id=\"style\">\nstyle </h3> <p>The <code>style</code> attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM <code>style</code> JavaScript property, is more efficient, and prevents XSS security holes. For example:</p> <pre class=\"highlight\" data-language=\"js\">const divStyle = {\n  color: 'blue',\n  backgroundImage: 'url(' + imgUrl + ')',\n};\n\nfunction HelloWorldComponent() {\n  return &lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;;\n}</pre> <p>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</p> <pre class=\"highlight\" data-language=\"js\">const divStyle = {\n  WebkitTransition: 'all', // note the capital 'W' here\n  msTransition: 'all' // 'ms' is the only lowercase vendor prefix\n};\n\nfunction ComponentWithTransition() {\n  return &lt;div style={divStyle}&gt;This should work cross-browser&lt;/div&gt;;\n}</pre> <p>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. <code>node.style.backgroundImage</code>). Vendor prefixes <a href=\"http://www.andismith.com/blog/2012/02/modernizr-prefixed/\">other than <code>ms</code></a> should begin with a capital letter. This is why <code>WebkitTransition</code> has an uppercase \"W\".</p> <h3 id=\"suppresscontenteditablewarning\">\nsuppressContentEditableWarning </h3> <p>Normally, there is a warning when an element with children is also marked as <code>contentEditable</code>, because it won't work. This attribute suppresses that warning. Don't use this unless you are building a library like <a href=\"https://facebook.github.io/draft-js/\">Draft.js</a> that manages <code>contentEditable</code> manually.</p> <h3 id=\"value\">\nvalue </h3> <p>The <code>value</code> attribute is supported by <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> components. You can use it to set the value of the component. This is useful for building controlled components. <code>defaultValue</code> is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</p> <h2 id=\"all-supported-html-attributes\">\nAll Supported HTML Attributes </h2> <p>React supports all <code>data-*</code> and <code>aria-*</code> attributes as well as these attributes:</p> <pre class=\"highlight\" data-language=\"text\">accept acceptCharset accessKey action allowFullScreen allowTransparency alt\nasync autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\ncharSet checked cite classID className colSpan cols content contentEditable\ncontextMenu controls coords crossOrigin data dateTime default defer dir\ndisabled download draggable encType form formAction formEncType formMethod\nformNoValidate formTarget frameBorder headers height hidden high href hrefLang\nhtmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label\nlang list loop low manifest marginHeight marginWidth max maxLength media\nmediaGroup method min minLength multiple muted name noValidate nonce open\noptimum pattern placeholder poster preload profile radioGroup readOnly rel\nrequired reversed role rowSpan rows sandbox scope scoped scrolling seamless\nselected shape size sizes span spellCheck src srcDoc srcLang srcSet start step\nstyle summary tabIndex target title type useMap value width wmode wrap</pre> <p>These RDFa attributes are supported (several RDFa attributes overlap with standard HTML attributes and thus are excluded from this list):</p> <pre class=\"highlight\" data-language=\"text\">about datatype inlist prefix property resource typeof vocab</pre> <p>In addition, the following non-standard attributes are supported:</p> <ul> <li>\n<code>autoCapitalize autoCorrect</code> for Mobile Safari.</li> <li>\n<code>color</code> for <code>&lt;link rel=\"mask-icon\" /&gt;</code> in Safari.</li> <li>\n<code>itemProp itemScope itemType itemRef itemID</code> for <a href=\"http://schema.org/docs/gs.html\">HTML5 microdata</a>.</li> <li>\n<code>security</code> for older versions of Internet Explorer.</li> <li>\n<code>unselectable</code> for Internet Explorer.</li> <li>\n<code>results autoSave</code> for WebKit/Blink input fields of type <code>search</code>.</li> </ul> <h2 id=\"all-supported-svg-attributes\">\nAll Supported SVG Attributes </h2> <p>React supports these SVG attributes:</p> <pre class=\"highlight\" data-language=\"text\">accentHeight accumulate additive alignmentBaseline allowReorder alphabetic\namplitude arabicForm ascent attributeName attributeType autoReverse azimuth\nbaseFrequency baseProfile baselineShift bbox begin bias by calcMode capHeight\nclip clipPath clipPathUnits clipRule colorInterpolation\ncolorInterpolationFilters colorProfile colorRendering contentScriptType\ncontentStyleType cursor cx cy d decelerate descent diffuseConstant direction\ndisplay divisor dominantBaseline dur dx dy edgeMode elevation enableBackground\nend exponent externalResourcesRequired fill fillOpacity fillRule filter\nfilterRes filterUnits floodColor floodOpacity focusable fontFamily fontSize\nfontSizeAdjust fontStretch fontStyle fontVariant fontWeight format from fx fy\ng1 g2 glyphName glyphOrientationHorizontal glyphOrientationVertical glyphRef\ngradientTransform gradientUnits hanging horizAdvX horizOriginX ideographic\nimageRendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength\nkerning keyPoints keySplines keyTimes lengthAdjust letterSpacing lightingColor\nlimitingConeAngle local markerEnd markerHeight markerMid markerStart\nmarkerUnits markerWidth mask maskContentUnits maskUnits mathematical mode\nnumOctaves offset opacity operator order orient orientation origin overflow\noverlinePosition overlineThickness paintOrder panose1 pathLength\npatternContentUnits patternTransform patternUnits pointerEvents points\npointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits\nr radius refX refY renderingIntent repeatCount repeatDur requiredExtensions\nrequiredFeatures restart result rotate rx ry scale seed shapeRendering slope\nspacing specularConstant specularExponent speed spreadMethod startOffset\nstdDeviation stemh stemv stitchTiles stopColor stopOpacity\nstrikethroughPosition strikethroughThickness string stroke strokeDasharray\nstrokeDashoffset strokeLinecap strokeLinejoin strokeMiterlimit strokeOpacity\nstrokeWidth surfaceScale systemLanguage tableValues targetX targetY textAnchor\ntextDecoration textLength textRendering to transform u1 u2 underlinePosition\nunderlineThickness unicode unicodeBidi unicodeRange unitsPerEm vAlphabetic\nvHanging vIdeographic vMathematical values vectorEffect version vertAdvY\nvertOriginX vertOriginY viewBox viewTarget visibility widths wordSpacing\nwritingMode x x1 x2 xChannelSelector xHeight xlinkActuate xlinkArcrole\nxlinkHref xlinkRole xlinkShow xlinkTitle xlinkType xmlns xmlnsXlink xmlBase\nxmlLang xmlSpace y y1 y2 yChannelSelector z zoomAndPan</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/dom-elements.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/dom-elements.html</a>\n  </p>\n</div>\n","state-and-lifecycle":"<h1> State and Lifecycle </h1>  <p>Consider the ticking clock example from <a href=\"rendering-elements#updating-the-rendered-element\">one of the previous sections</a>.</p> <p>So far we have only learned one way to update the UI.</p> <p>We call <code>ReactDOM.render()</code> to change the rendered output:</p> <pre class=\"highlight\" data-language=\"js\">function tick() {\n  const element = (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);</pre> <p><a href=\"http://codepen.io/gaearon/pen/gwoJZk?editors=0010\">Try it on CodePen.</a></p> <p>In this section, we will learn how to make the <code>Clock</code> component truly reusable and encapsulated. It will set up its own timer and update itself every second.</p> <p>We can start by encapsulating how the clock looks:</p> <pre class=\"highlight\" data-language=\"js\">function Clock(props) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    &lt;Clock date={new Date()} /&gt;,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);</pre> <p><a href=\"http://codepen.io/gaearon/pen/dpdoYR?editors=0010\">Try it on CodePen.</a></p> <p>However, it misses a crucial requirement: the fact that the <code>Clock</code> sets up a timer and updates the UI every second should be an implementation detail of the <code>Clock</code>.</p> <p>Ideally we want to write this once and have the <code>Clock</code> update itself:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n);</pre> <p>To implement this, we need to add \"state\" to the <code>Clock</code> component.</p> <p>State is similar to props, but it is private and fully controlled by the component.</p> <p>We <a href=\"components-and-props#functional-and-class-components\">mentioned before</a> that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.</p> <h2 id=\"converting-a-function-to-a-class\">\nConverting a Function to a Class </h2> <p>You can convert a functional component like <code>Clock</code> to a class in five steps:</p> <ol> <li><p>Create an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 class</a> with the same name that extends <code>React.Component</code>.</p></li> <li><p>Add a single empty method to it called <code>render()</code>.</p></li> <li><p>Move the body of the function into the <code>render()</code> method.</p></li> <li><p>Replace <code>props</code> with <code>this.props</code> in the <code>render()</code> body.</p></li> <li><p>Delete the remaining empty function declaration.</p></li> </ol> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/zKRGpo?editors=0010\">Try it on CodePen.</a></p> <p><code>Clock</code> is now defined as a class rather than a function.</p> <p>This lets us use additional features such as local state and lifecycle hooks.</p> <h2 id=\"adding-local-state-to-a-class\">\nAdding Local State to a Class </h2> <p>We will move the <code>date</code> from props to state in three steps:</p> <p>1) Replace <code>this.props.date</code> with <code>this.state.date</code> in the <code>render()</code> method:</p> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p>2) Add a <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor\">class constructor</a> that assigns the initial <code>this.state</code>:</p> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p>Note how we pass <code>props</code> to the base constructor:</p> <pre class=\"highlight\" data-language=\"js\">constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }</pre> <p>Class components should always call the base constructor with <code>props</code>.</p> <p>3) Remove the <code>date</code> prop from the <code>&lt;Clock /&gt;</code> element:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n);</pre> <p>We will later add the timer code back to the component itself.</p> <p>The result looks like this:</p> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/KgQpJd?editors=0010\">Try it on CodePen.</a></p> <p>Next, we'll make the <code>Clock</code> set up its own timer and update itself every second.</p> <h2 id=\"adding-lifecycle-methods-to-a-class\">\nAdding Lifecycle Methods to a Class </h2> <p>In applications with many components, it's very important to free up resources taken by the components when they are destroyed.</p> <p>We want to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval\">set up a timer</a> whenever the <code>Clock</code> is rendered to the DOM for the first time. This is called \"mounting\" in React.</p> <p>We also want to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval\">clear that timer</a> whenever the DOM produced by the <code>Clock</code> is removed. This is called \"unmounting\" in React.</p> <p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p>These methods are called \"lifecycle hooks\".</p> <p>The <code>componentDidMount()</code> hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p> <pre class=\"highlight\" data-language=\"js\">componentDidMount() {\n    this.timerID = setInterval(\n      () =&gt; this.tick(),\n      1000\n    );\n  }</pre> <p>Note how we save the timer ID right on <code>this</code>.</p> <p>While <code>this.props</code> is set up by React itself and <code>this.state</code> has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.</p> <p>If you don't use something in <code>render()</code>, it shouldn't be in the state.</p> <p>We will tear down the timer in the <code>componentWillUnmount()</code> lifecycle hook:</p> <pre class=\"highlight\" data-language=\"js\">componentWillUnmount() {\n    clearInterval(this.timerID);\n  }</pre> <p>Finally, we will implement the <code>tick()</code> method that runs every second.</p> <p>It will use <code>this.setState()</code> to schedule updates to the component local state:</p> <pre class=\"highlight\" data-language=\"js\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () =&gt; this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/amqdNA?editors=0010\">Try it on CodePen.</a></p> <p>Now the clock ticks every second.</p> <p>Let's quickly recap what's going on and the order in which the methods are called:</p> <p>1) When <code>&lt;Clock /&gt;</code> is passed to <code>ReactDOM.render()</code>, React calls the constructor of the <code>Clock</code> component. Since <code>Clock</code> needs to display the current time, it initializes <code>this.state</code> with an object including the current time. We will later update this state.</p> <p>2) React then calls the <code>Clock</code> component's <code>render()</code> method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the <code>Clock</code>'s render output.</p> <p>3) When the <code>Clock</code> output is inserted in the DOM, React calls the <code>componentDidMount()</code> lifecycle hook. Inside it, the <code>Clock</code> component asks the browser to set up a timer to call <code>tick()</code> once a second.</p> <p>4) Every second the browser calls the <code>tick()</code> method. Inside it, the <code>Clock</code> component schedules a UI update by calling <code>setState()</code> with an object containing the current time. Thanks to the <code>setState()</code> call, React knows the state has changed, and calls <code>render()</code> method again to learn what should be on the screen. This time, <code>this.state.date</code> in the <code>render()</code> method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</p> <p>5) If the <code>Clock</code> component is ever removed from the DOM, React calls the <code>componentWillUnmount()</code> lifecycle hook so the timer is stopped.</p> <h2 id=\"using-state-correctly\">\nUsing State Correctly </h2> <p>There are three things you should know about <code>setState()</code>.</p> <h3 id=\"do-not-modify-state-directly\">\nDo Not Modify State Directly </h3> <p>For example, this will not re-render a component:</p> <pre class=\"highlight\" data-language=\"js\">// Wrong\nthis.state.comment = 'Hello';</pre> <p>Instead, use <code>setState()</code>:</p> <pre class=\"highlight\" data-language=\"js\">// Correct\nthis.setState({comment: 'Hello'});</pre> <p>The only place where you can assign <code>this.state</code> is the constructor.</p> <h3 id=\"state-updates-may-be-asynchronous\">\nState Updates May Be Asynchronous </h3> <p>React may batch multiple <code>setState()</code> calls into a single update for performance.</p> <p>Because <code>this.props</code> and <code>this.state</code> may be updated asynchronously, you should not rely on their values for calculating the next state.</p> <p>For example, this code may fail to update the counter:</p> <pre class=\"highlight\" data-language=\"js\">// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});</pre> <p>To fix it, use a second form of <code>setState()</code> that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p> <pre class=\"highlight\" data-language=\"js\">// Correct\nthis.setState((prevState, props) =&gt; ({\n  counter: prevState.counter + props.increment\n}));</pre> <p>We used an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow function</a> above, but it also works with regular functions:</p> <pre class=\"highlight\" data-language=\"js\">// Correct\nthis.setState(function(prevState, props) {\n  return {\n    counter: prevState.counter + props.increment\n  };\n});</pre>\n<h3 id=\"state-updates-are-merged\">\nState Updates are Merged </h3> <p>When you call <code>setState()</code>, React merges the object you provide into the current state.</p> <p>For example, your state may contain several independent variables:</p> <pre class=\"highlight\" data-language=\"js\">constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],\n      comments: []\n    };\n  }</pre> <p>Then you can update them independently with separate <code>setState()</code> calls:</p> <pre class=\"highlight\" data-language=\"js\">componentDidMount() {\n    fetchPosts().then(response =&gt; {\n      this.setState({\n        posts: response.posts\n      });\n    });\n\n    fetchComments().then(response =&gt; {\n      this.setState({\n        comments: response.comments\n      });\n    });\n  }</pre> <p>The merging is shallow, so <code>this.setState({comments})</code> leaves <code>this.state.posts</code> intact, but completely replaces <code>this.state.comments</code>.</p> <h2 id=\"the-data-flows-down\">\nThe Data Flows Down </h2> <p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn't care whether it is defined as a function or a class.</p> <p>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p> <p>A component may choose to pass its state down as props to its child components:</p> <pre class=\"highlight\" data-language=\"js\">&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;</pre> <p>This also works for user-defined components:</p> <pre class=\"highlight\" data-language=\"js\">&lt;FormattedDate date={this.state.date} /&gt;</pre> <p>The <code>FormattedDate</code> component would receive the <code>date</code> in its props and wouldn't know whether it came from the <code>Clock</code>'s state, from the <code>Clock</code>'s props, or was typed by hand:</p> <pre class=\"highlight\" data-language=\"js\">function FormattedDate(props) {\n  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/zKRqNB?editors=0010\">Try it on CodePen.</a></p> <p>This is commonly called a \"top-down\" or \"unidirectional\" data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components \"below\" them in the tree.</p> <p>If you imagine a component tree as a waterfall of props, each component's state is like an additional water source that joins it at an arbitrary point but also flows down.</p> <p>To show that all components are truly isolated, we can create an <code>App</code> component that renders three <code>&lt;Clock&gt;</code>s:</p> <pre class=\"highlight\" data-language=\"js\">function App() {\n  return (\n    &lt;div&gt;\n      &lt;Clock /&gt;\n      &lt;Clock /&gt;\n      &lt;Clock /&gt;\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(\n  &lt;App /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/vXdGmd?editors=0010\">Try it on CodePen.</a></p> <p>Each <code>Clock</code> sets up its own timer and updates independently.</p> <p>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/state-and-lifecycle.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/state-and-lifecycle.html</a>\n  </p>\n</div>\n","conditional-rendering":"<h1> Conditional Rendering </h1>  <p>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</p> <p>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\"><code>if</code></a> or the <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">conditional operator</a> to create elements representing the current state, and let React update the UI to match them.</p> <p>Consider these two components:</p> <pre class=\"highlight\" data-language=\"js\">function UserGreeting(props) {\n  return &lt;h1&gt;Welcome back!&lt;/h1&gt;;\n}\n\nfunction GuestGreeting(props) {\n  return &lt;h1&gt;Please sign up.&lt;/h1&gt;;\n}</pre> <p>We'll create a <code>Greeting</code> component that displays either of these components depending on whether a user is logged in:</p> <pre class=\"highlight\" data-language=\"javascript\">function Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return &lt;UserGreeting /&gt;;\n  }\n  return &lt;GuestGreeting /&gt;;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  &lt;Greeting isLoggedIn={false} /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/ZpVxNq?editors=0011\">Try it on CodePen.</a></p> <p>This example renders a different greeting depending on the value of <code>isLoggedIn</code> prop.</p> <h3 id=\"element-variables\">\nElement Variables </h3> <p>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn't change.</p> <p>Consider these two new components representing Logout and Login buttons:</p> <pre class=\"highlight\" data-language=\"js\">function LoginButton(props) {\n  return (\n    &lt;button onClick={props.onClick}&gt;\n      Login\n    &lt;/button&gt;\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    &lt;button onClick={props.onClick}&gt;\n      Logout\n    &lt;/button&gt;\n  );\n}</pre> <p>In the example below, we will create a <a href=\"state-and-lifecycle#adding-local-state-to-a-class\">stateful component</a> called <code>LoginControl</code>.</p> <p>It will render either <code>&lt;LoginButton /&gt;</code> or <code>&lt;LogoutButton /&gt;</code> depending on its current state. It will also render a <code>&lt;Greeting /&gt;</code> from the previous example:</p> <pre class=\"highlight\" data-language=\"javascript\">class LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n\n    let button = null;\n    if (isLoggedIn) {\n      button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;\n    } else {\n      button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;\n    }\n\n    return (\n      &lt;div&gt;\n        &lt;Greeting isLoggedIn={isLoggedIn} /&gt;\n        {button}\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;LoginControl /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/QKzAgB?editors=0010\">Try it on CodePen.</a></p> <p>While declaring a variable and using an <code>if</code> statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</p> <h3 id=\"inline-if-with-logical-ampamp-operator\">\nInline If with Logical &amp;&amp; Operator </h3> <p>You may <a href=\"introducing-jsx#embedding-expressions-in-jsx\">embed any expressions in JSX</a> by wrapping them in curly braces. This includes the JavaScript logical <code>&amp;&amp;</code> operator. It can be handy for conditionally including an element:</p> <pre class=\"highlight\" data-language=\"js\">function Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello!&lt;/h1&gt;\n      {unreadMessages.length &gt; 0 &amp;&amp;\n        &lt;h2&gt;\n          You have {unreadMessages.length} unread messages.\n        &lt;/h2&gt;\n      }\n    &lt;/div&gt;\n  );\n}\n\nconst messages = ['React', 'Re: React', 'Re:Re: React'];\nReactDOM.render(\n  &lt;Mailbox unreadMessages={messages} /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/ozJddz?editors=0010\">Try it on CodePen.</a></p> <p>It works because in JavaScript, <code>true &amp;&amp; expression</code> always evaluates to <code>expression</code>, and <code>false &amp;&amp; expression</code> always evaluates to <code>false</code>.</p> <p>Therefore, if the condition is <code>true</code>, the element right after <code>&amp;&amp;</code> will appear in the output. If it is <code>false</code>, React will ignore and skip it.</p> <h3 id=\"inline-if-else-with-conditional-operator\">\nInline If-Else with Conditional Operator </h3> <p>Another method for conditionally rendering elements inline is to use the JavaScript conditional operator <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\"><code>condition ? true : false</code></a>.</p> <p>In the example below, we use it to conditionally render a small block of text.</p> <pre class=\"highlight\" data-language=\"javascript\">render() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    &lt;div&gt;\n      The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.\n    &lt;/div&gt;\n  );\n}</pre> <p>It can also be used for larger expressions although it is less obvious what's going on:</p> <pre class=\"highlight\" data-language=\"js\">render() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    &lt;div&gt;\n      {isLoggedIn ? (\n        &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;\n      ) : (\n        &lt;LoginButton onClick={this.handleLoginClick} /&gt;\n      )}\n    &lt;/div&gt;\n  );\n}</pre> <p>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to <a href=\"components-and-props#extracting-components\">extract a component</a>.</p> <h3 id=\"preventing-component-from-rendering\">\nPreventing Component from Rendering </h3> <p>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return <code>null</code> instead of its render output.</p> <p>In the example below, the <code>&lt;WarningBanner /&gt;</code> is rendered depending on the value of the prop called <code>warn</code>. If the value of the prop is <code>false</code>, then the component does not render:</p> <pre class=\"highlight\" data-language=\"javascript\">function WarningBanner(props) {\n  if (!props.warn) {\n    return null;\n  }\n\n  return (\n    &lt;div className=\"warning\"&gt;\n      Warning!\n    &lt;/div&gt;\n  );\n}\n\nclass Page extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {showWarning: true}\n    this.handleToggleClick = this.handleToggleClick.bind(this);\n  }\n\n  handleToggleClick() {\n    this.setState(prevState =&gt; ({\n      showWarning: !prevState.showWarning\n    }));\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;WarningBanner warn={this.state.showWarning} /&gt;\n        &lt;button onClick={this.handleToggleClick}&gt;\n          {this.state.showWarning ? 'Hide' : 'Show'}\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;Page /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"https://codepen.io/gaearon/pen/Xjoqwm?editors=0010\">Try it on CodePen.</a></p> <p>Returning <code>null</code> from a component's <code>render</code> method does not affect the firing of the component's lifecycle methods. For instance, <code>componentWillUpdate</code> and <code>componentDidUpdate</code> will still be called.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/conditional-rendering.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/conditional-rendering.html</a>\n  </p>\n</div>\n","addons":"<h1> Add-Ons </h1>  <p>The React add-ons are a collection of useful utility modules for building React apps. <strong>These should be considered experimental</strong> and tend to change more often than the core.</p> <ul> <li>\n<a href=\"animation\"><code>TransitionGroup</code> and <code>CSSTransitionGroup</code></a>, for dealing with animations and transitions that are usually not simple to implement, such as before a component's removal.</li> <li>\n<a href=\"create-fragment\"><code>createFragment</code></a>, to create a set of externally-keyed children.</li> </ul> <p>The add-ons below are in the development (unminified) version of React only:</p> <ul> <li>\n<a href=\"perf\"><code>Perf</code></a>, a performance profiling tool for finding optimization opportunities.</li> <li>\n<a href=\"test-utils\"><code>ReactTestUtils</code></a>, simple helpers for writing test cases.</li> </ul> <h3 id=\"legacy-add-ons\">\nLegacy Add-ons </h3> <p>The add-ons below are considered legacy and their use is discouraged.</p> <ul> <li>\n<a href=\"pure-render-mixin\"><code>PureRenderMixin</code></a>. Use <a href=\"react-api#react.purecomponent\"><code>React.PureComponent</code></a> instead.</li> <li>\n<a href=\"shallow-compare\"><code>shallowCompare</code></a>, a helper function that performs a shallow comparison for props and state in a component to decide if a component should update.</li> <li>\n<a href=\"update\"><code>update</code></a>. Use <a href=\"https://github.com/kolodny/immutability-helper\"><code>kolodny/immutability-helper</code></a> instead.</li> </ul> <h3 id=\"deprecated-add-ons\">\nDeprecated Add-ons </h3> <p><a href=\"two-way-binding-helpers\"><code>LinkedStateMixin</code></a> has been deprecated.</p> <h2 id=\"using-react-with-add-ons\">\nUsing React with Add-ons </h2> <p>If using npm, you can install the add-ons individually from npm (e.g. <code>npm install react-addons-test-utils</code>) and import them:</p> <pre class=\"highlight\" data-language=\"javascript\">import Perf from 'react-addons-perf'; // ES6\nvar Perf = require('react-addons-perf'); // ES5 with npm</pre> <p>When using a CDN, you can use <code>react-with-addons.js</code> instead of <code>react.js</code>:</p> <pre class=\"highlight\" data-language=\"html\">&lt;script src=\"https://unpkg.com/react@15/dist/react-with-addons.js\"&gt;&lt;/script&gt;</pre> <p>The add-ons will be available via the <code>React.addons</code> global (e.g. <code>React.addons.TestUtils</code>).</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/addons.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/addons.html</a>\n  </p>\n</div>\n","handling-events":"<h1> Handling Events </h1>  <p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</p> <ul> <li>React events are named using camelCase, rather than lowercase.</li> <li>With JSX you pass a function as the event handler, rather than a string.</li> </ul> <p>For example, the HTML:</p> <pre class=\"highlight\" data-language=\"html\">&lt;button onclick=\"activateLasers()\"&gt;\n  Activate Lasers\n&lt;/button&gt;</pre> <p>is slightly different in React:</p> <pre class=\"highlight\" data-language=\"js\">&lt;button onClick={activateLasers}&gt;\n  Activate Lasers\n&lt;/button&gt;</pre> <p>Another difference is that you cannot return <code>false</code> to prevent default behavior in React. You must call <code>preventDefault</code> explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</p> <pre class=\"highlight\" data-language=\"html\">&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\"&gt;\n  Click me\n&lt;/a&gt;</pre> <p>In React, this could instead be:</p> <pre class=\"highlight\" data-language=\"js\">function ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n\n  return (\n    &lt;a href=\"#\" onClick={handleClick}&gt;\n      Click me\n    &lt;/a&gt;\n  );\n}</pre> <p>Here, <code>e</code> is a synthetic event. React defines these synthetic events according to the <a href=\"https://www.w3.org/TR/DOM-Level-3-Events/\">W3C spec</a>, so you don't need to worry about cross-browser compatibility. See the <a href=\"events\"><code>SyntheticEvent</code></a> reference guide to learn more.</p> <p>When using React you should generally not need to call <code>addEventListener</code> to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p> <p>When you define a component using an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this <code>Toggle</code> component renders a button that lets the user toggle between \"ON\" and \"OFF\" states:</p> <pre class=\"highlight\" data-language=\"js\">class Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState =&gt; ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      &lt;/button&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;Toggle /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/xEmzGg?editors=0010\">Try it on CodePen.</a></p> <p>You have to be careful about the meaning of <code>this</code> in JSX callbacks. In JavaScript, class methods are not <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\">bound</a> by default. If you forget to bind <code>this.handleClick</code> and pass it to <code>onClick</code>, <code>this</code> will be <code>undefined</code> when the function is actually called.</p> <p>This is not React-specific behavior; it is a part of <a href=\"https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/\">how functions work in JavaScript</a>. Generally, if you refer to a method without <code>()</code> after it, such as <code>onClick={this.handleClick}</code>, you should bind that method.</p> <p>If calling <code>bind</code> annoys you, there are two ways you can get around this. If you are using the experimental <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\">property initializer syntax</a>, you can use property initializers to correctly bind callbacks:</p> <pre class=\"highlight\" data-language=\"js\">class LoggingButton extends React.Component {\n  // This syntax ensures `this` is bound within handleClick.\n  // Warning: this is *experimental* syntax.\n  handleClick = () =&gt; {\n    console.log('this is:', this);\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        Click me\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>This syntax is enabled by default in <a href=\"https://github.com/facebookincubator/create-react-app\">Create React App</a>.</p> <p>If you aren't using property initializer syntax, you can use an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow function</a> in the callback:</p> <pre class=\"highlight\" data-language=\"js\">class LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // This syntax ensures `this` is bound within handleClick\n    return (\n      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;\n        Click me\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>The problem with this syntax is that a different callback is created each time the <code>LoggingButton</code> renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the property initializer syntax, to avoid this sort of performance problem.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/handling-events.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/handling-events.html</a>\n  </p>\n</div>\n","perf":"<h1> Performance Tools </h1>  <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import Perf from 'react-addons-perf' // ES6\nvar Perf = require('react-addons-perf') // ES5 with npm\nvar Perf = React.addons.Perf; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p>React is usually quite fast out of the box. However, in situations where you need to squeeze every ounce of performance out of your app, it provides a <a href=\"react-component#shouldcomponentupdate\">shouldComponentUpdate()</a> hook where you can add optimization hints to React's diff algorithm.</p> <p>In addition to giving you an overview of your app's overall performance, <code>Perf</code> is a profiling tool that tells you exactly where you need to put these hooks.</p> <p>See these articles by the <a href=\"http://benchling.engineering\">Benchling Engineering Team</a> for a in-depth introduction to performance tooling:</p> <ul> <li><a href=\"http://benchling.engineering/performance-engineering-with-react/\">\"Performance Engineering with React\"</a></li> <li><a href=\"http://benchling.engineering/deep-dive-react-perf-debugging/\">\"A Deep Dive into React Perf Debugging\"</a></li> </ul> <h3 id=\"development-vs.-production-builds\">\nDevelopment vs. Production Builds </h3> <p>If you're benchmarking or seeing performance problems in your React apps, make sure you're testing with the <a href=\"https://facebook.github.io/react/downloads.html\">minified production build</a>. The development build includes extra warnings that are helpful when building your apps, but it is slower due to the extra bookkeeping it does.</p> <p>However, the perf tools described on this page only work when using the development build of React. Therefore, the profiler only serves to indicate the <em>relatively</em> expensive parts of your app.</p> <h3 id=\"using-perf\">\nUsing Perf </h3> <p>The <code>Perf</code> object can be used with React in development mode only. You should not include this bundle when building your app for production.</p> <h4 id=\"getting-measurements\">\nGetting Measurements </h4> <ul> <li><a href=\"#start\"><code>start()</code></a></li> <li><a href=\"#stop\"><code>stop()</code></a></li> <li><a href=\"#getlastmeasurements\"><code>getLastMeasurements()</code></a></li> </ul> <h4 id=\"printing-results\">\nPrinting Results </h4> <p>The following methods use the measurements returned by <a href=\"#getlastmeasurements\"><code>Perf.getLastMeasurements()</code></a> to pretty-print the result.</p> <ul> <li><a href=\"#printinclusive\"><code>printInclusive()</code></a></li> <li><a href=\"#printexclusive\"><code>printExclusive()</code></a></li> <li><a href=\"#printwasted\"><code>printWasted()</code></a></li> <li><a href=\"#printoperations\"><code>printOperations()</code></a></li> <li><a href=\"#printdom\"><code>printDOM()</code></a></li> </ul>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"start\">\n<code>start()</code> </h3>\n<h3 id=\"stop\">\n<code>stop()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.start()\n// ...\nPerf.stop()</pre> <p>Start/stop the measurement. The React operations in-between are recorded for analyses below. Operations that took an insignificant amount of time are ignored.</p> <p>After stopping, you will need <a href=\"#getlastmeasurements\"><code>Perf.getLastMeasurements()</code></a> to get the measurements.</p>  <h3 id=\"getlastmeasurements\">\n<code>getLastMeasurements()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.getLastMeasurements()</pre> <p>Get the opaque data structure describing measurements from the last start-stop session. You can save it and pass it to the other print methods in <a href=\"#printing-results\"><code>Perf</code></a> to analyze past measurements.</p> <blockquote> <p>Note</p> <p>Don't rely on the exact format of the return value because it may change in minor releases. We will update the documentation if the return value format becomes a supported part of the public API.</p> </blockquote>  <h3 id=\"printinclusive\">\n<code>printInclusive()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.printInclusive(measurements)</pre> <p>Prints the overall time taken. If no argument's passed, defaults to all the measurements from the last recording. This prints a nicely formatted table in the console, like so:</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-inclusive.png\" alt=\"\"></p>  <h3 id=\"printexclusive\">\n<code>printExclusive()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.printExclusive(measurements)</pre> <p>\"Exclusive\" times don't include the times taken to mount the components: processing props, calling <code>componentWillMount</code> and <code>componentDidMount</code>, etc.</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-exclusive.png\" alt=\"\"></p>  <h3 id=\"printwasted\">\n<code>printWasted()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.printWasted(measurements)</pre> <p><strong>The most useful part of the profiler</strong>.</p> <p>\"Wasted\" time is spent on components that didn't actually render anything, e.g. the render stayed the same, so the DOM wasn't touched.</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-wasted.png\" alt=\"\"></p>  <h3 id=\"printoperations\">\n<code>printOperations()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.printOperations(measurements)</pre> <p>Prints the underlying DOM manipulations, e.g. \"set innerHTML\" and \"remove\".</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-dom.png\" alt=\"\"></p>  <h3 id=\"printdom\">\n<code>printDOM()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Perf.printDOM(measurements)</pre> <p>This method has been renamed to <a href=\"#printoperations\"><code>printOperations()</code></a>. Currently <code>printDOM()</code> still exists as an alias but it prints a deprecation warning and will eventually be removed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/perf.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/perf.html</a>\n  </p>\n</div>\n","create-fragment":"<h1> Keyed Fragments </h1>  <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import createFragment from 'react-addons-create-fragment' // ES6\nvar createFragment = require('react-addons-create-fragment') // ES5 with npm\nvar createFragment = React.addons.createFragment; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p>In most cases, you can use the <code>key</code> prop to specify keys on the elements you're returning from <code>render</code>. However, this breaks down in one situation: if you have two sets of children that you need to reorder, there's no way to put a key on each set without adding a wrapper element.</p> <p>That is, if you have a component such as:</p> <pre class=\"highlight\" data-language=\"js\">function Swapper(props) {\n  let children;\n  if (props.swapped) {\n    children = [props.rightChildren, props.leftChildren];\n  } else {\n    children = [props.leftChildren, props.rightChildren];\n  }\n  return &lt;div&gt;{children}&lt;/div&gt;;\n}</pre> <p>The children will unmount and remount as you change the <code>swapped</code> prop because there aren't any keys marked on the two sets of children.</p> <p>To solve this problem, you can use the <code>createFragment</code> add-on to give keys to the sets of children.</p> <h4 id=\"arrayltreactnodegt-createfragmentobject-children\">\n<code>Array&lt;ReactNode&gt; createFragment(object children)</code> </h4> <p>Instead of creating arrays, we write:</p> <pre class=\"highlight\" data-language=\"js\">import createFragment from 'react-addons-create-fragment'\n\nfunction Swapper(props) {\n  let children;\n  if (props.swapped) {\n    children = createFragment({\n      right: props.rightChildren,\n      left: props.leftChildren\n    });\n  } else {\n    children = createFragment({\n      left: props.leftChildren,\n      right: props.rightChildren\n    });\n  }\n  return &lt;div&gt;{children}&lt;/div&gt;;\n}</pre> <p>The keys of the passed object (that is, <code>left</code> and <code>right</code>) are used as keys for the entire set of children, and the order of the object's keys is used to determine the order of the rendered children. With this change, the two sets of children will be properly reordered in the DOM without unmounting.</p> <p>The return value of <code>createFragment</code> should be treated as an opaque object; you can use the <a href=\"react-api#react.children\"><code>React.Children</code></a> helpers to loop through a fragment but should not access it directly. Note also that we're relying on the JavaScript engine preserving object enumeration order here, which is not guaranteed by the spec but is implemented by all major browsers and VMs for objects with non-numeric keys.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/create-fragment.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/create-fragment.html</a>\n  </p>\n</div>\n","animation":"<h1> Animation Add-Ons </h1>  <p>The <a href=\"#low-level-api-reacttransitiongroup\"><code>ReactTransitionGroup</code></a> add-on component is a low-level API for animation, and <a href=\"#high-level-api-reactcsstransitiongroup\"><code>ReactCSSTransitionGroup</code></a> is an add-on component for easily implementing basic CSS animations and transitions.</p> <h2 id=\"high-level-api-reactcsstransitiongroup\">\nHigh-level API: ReactCSSTransitionGroup </h2> <p><code>ReactCSSTransitionGroup</code> is a high-level API based on <a href=\"#low-level-api-reacttransitiongroup\"><code>ReactTransitionGroup</code></a> and is an easy way to perform CSS transitions and animations when a React component enters or leaves the DOM. It's inspired by the excellent <a href=\"http://www.nganimate.org/\">ng-animate</a> library.</p> <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import ReactCSSTransitionGroup from 'react-addons-css-transition-group' // ES6\nvar ReactCSSTransitionGroup = require('react-addons-css-transition-group') // ES5 with npm\nvar ReactCSSTransitionGroup = React.addons.CSSTransitionGroup; // ES5 with react-with-addons.js</pre>\n<pre class=\"highlight\" data-language=\"javascript\">class TodoList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {items: ['hello', 'world', 'click', 'me']};\n    this.handleAdd = this.handleAdd.bind(this);\n  }\n\n  handleAdd() {\n    const newItems = this.state.items.concat([\n      prompt('Enter some text')\n    ]);\n    this.setState({items: newItems});\n  }\n\n  handleRemove(i) {\n    let newItems = this.state.items.slice();\n    newItems.splice(i, 1);\n    this.setState({items: newItems});\n  }\n\n  render() {\n    const items = this.state.items.map((item, i) =&gt; (\n      &lt;div key={item} onClick={() =&gt; this.handleRemove(i)}&gt;\n        {item}\n      &lt;/div&gt;\n    ));\n\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleAdd}&gt;Add Item&lt;/button&gt;\n        &lt;ReactCSSTransitionGroup\n          transitionName=\"example\"\n          transitionEnterTimeout={500}\n          transitionLeaveTimeout={300}&gt;\n          {items}\n        &lt;/ReactCSSTransitionGroup&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <blockquote>  <p>You must provide <a href=\"composition-vs-inheritance#dynamic-children\">the <code>key</code> attribute</a> for all children of <code>ReactCSSTransitionGroup</code>, even when only rendering a single item. This is how React will determine which children have entered, left, or stayed.</p> </blockquote> <p>In this component, when a new item is added to <code>ReactCSSTransitionGroup</code> it will get the <code>example-enter</code> CSS class and the <code>example-enter-active</code> CSS class added in the next tick. This is a convention based on the <code>transitionName</code> prop.</p> <p>You can use these classes to trigger a CSS animation or transition. For example, try adding this CSS and adding a new list item:</p> <pre class=\"highlight\" data-language=\"css\">.example-enter {\n  opacity: 0.01;\n}\n\n.example-enter.example-enter-active {\n  opacity: 1;\n  transition: opacity 500ms ease-in;\n}\n\n.example-leave {\n  opacity: 1;\n}\n\n.example-leave.example-leave-active {\n  opacity: 0.01;\n  transition: opacity 300ms ease-in;\n}</pre> <p>You'll notice that animation durations need to be specified in both the CSS and the render method; this tells React when to remove the animation classes from the element and -- if it's leaving -- when to remove the element from the DOM.</p> <h3 id=\"animate-initial-mounting\">\nAnimate Initial Mounting </h3> <p><code>ReactCSSTransitionGroup</code> provides the optional prop <code>transitionAppear</code>, to add an extra transition phase at the initial mount of the component. There is generally no transition phase at the initial mount as the default value of <code>transitionAppear</code> is <code>false</code>. The following is an example which passes the prop <code>transitionAppear</code> with the value <code>true</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">render() {\n  return (\n    &lt;ReactCSSTransitionGroup\n      transitionName=\"example\"\n      transitionAppear={true}\n      transitionAppearTimeout={500}\n      transitionEnter={false}\n      transitionLeave={false}&gt;\n      &lt;h1&gt;Fading at Initial Mount&lt;/h1&gt;\n    &lt;/ReactCSSTransitionGroup&gt;\n  );\n}</pre> <p>During the initial mount <code>ReactCSSTransitionGroup</code> will get the <code>example-appear</code> CSS class and the <code>example-appear-active</code> CSS class added in the next tick.</p> <pre class=\"highlight\" data-language=\"css\">.example-appear {\n  opacity: 0.01;\n}\n\n.example-appear.example-appear-active {\n  opacity: 1;\n  transition: opacity .5s ease-in;\n}</pre> <p>At the initial mount, all children of the <code>ReactCSSTransitionGroup</code> will <code>appear</code> but not <code>enter</code>. However, all children later added to an existing <code>ReactCSSTransitionGroup</code> will <code>enter</code> but not <code>appear</code>.</p> <blockquote>  <p>The prop <code>transitionAppear</code> was added to <code>ReactCSSTransitionGroup</code> in version <code>0.13</code>. To maintain backwards compatibility, the default value is set to <code>false</code>.</p> <p>However, the default values of <code>transitionEnter</code> and <code>transitionLeave</code> are <code>true</code> so you must specify <code>transitionEnterTimeout</code> and <code>transitionLeaveTimeout</code> by default. If you don't need either enter or leave animations, pass <code>transitionEnter={false}</code> or <code>transitionLeave={false}</code>.</p> </blockquote> <h3 id=\"custom-classes\">\nCustom Classes </h3> <p>It is also possible to use custom class names for each of the steps in your transitions. Instead of passing a string into transitionName you can pass an object containing either the <code>enter</code> and <code>leave</code> class names, or an object containing the <code>enter</code>, <code>enter-active</code>, <code>leave-active</code>, and <code>leave</code> class names. If only the enter and leave classes are provided, the enter-active and leave-active classes will be determined by appending '-active' to the end of the class name. Here are two examples using custom classes:</p> <pre class=\"highlight\" data-language=\"javascript\">// ...\n&lt;ReactCSSTransitionGroup\n  transitionName={ {\n    enter: 'enter',\n    enterActive: 'enterActive',\n    leave: 'leave',\n    leaveActive: 'leaveActive',\n    appear: 'appear',\n    appearActive: 'appearActive'\n  } }&gt;\n  {item}\n&lt;/ReactCSSTransitionGroup&gt;\n\n&lt;ReactCSSTransitionGroup\n  transitionName={ {\n    enter: 'enter',\n    leave: 'leave',\n    appear: 'appear'\n  } }&gt;\n  {item2}\n&lt;/ReactCSSTransitionGroup&gt;\n// ...</pre>\n<h3 id=\"animation-group-must-be-mounted-to-work\">\nAnimation Group Must Be Mounted To Work </h3> <p>In order for it to apply transitions to its children, the <code>ReactCSSTransitionGroup</code> must already be mounted in the DOM or the prop <code>transitionAppear</code> must be set to <code>true</code>.</p> <p>The example below would <strong>not</strong> work, because the <code>ReactCSSTransitionGroup</code> is being mounted along with the new item, instead of the new item being mounted within it. Compare this to the <a href=\"#getting-started\">Getting Started</a> section above to see the difference.</p> <pre class=\"highlight\" data-language=\"javascript\">render() {\n  const items = this.state.items.map((item, i) =&gt; (\n    &lt;div key={item} onClick={() =&gt; this.handleRemove(i)}&gt;\n      &lt;ReactCSSTransitionGroup transitionName=\"example\"&gt;\n        {item}\n      &lt;/ReactCSSTransitionGroup&gt;\n    &lt;/div&gt;\n  ));\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={this.handleAdd}&gt;Add Item&lt;/button&gt;\n      {items}\n    &lt;/div&gt;\n  );\n}</pre>\n<h3 id=\"animating-one-or-zero-items\">\nAnimating One or Zero Items </h3> <p>In the example above, we rendered a list of items into <code>ReactCSSTransitionGroup</code>. However, the children of <code>ReactCSSTransitionGroup</code> can also be one or zero items. This makes it possible to animate a single element entering or leaving. Similarly, you can animate a new element replacing the current element. For example, we can implement a simple image carousel like this:</p> <pre class=\"highlight\" data-language=\"javascript\">import ReactCSSTransitionGroup from 'react-addons-css-transition-group';\n\nfunction ImageCarousel(props) {\n  return (\n    &lt;div&gt;\n      &lt;ReactCSSTransitionGroup\n        transitionName=\"carousel\"\n        transitionEnterTimeout={300}\n        transitionLeaveTimeout={300}&gt;\n        &lt;img src={props.imageSrc} key={props.imageSrc} /&gt;\n      &lt;/ReactCSSTransitionGroup&gt;\n    &lt;/div&gt;\n  );\n}</pre>\n<h3 id=\"disabling-animations\">\nDisabling Animations </h3> <p>You can disable animating <code>enter</code> or <code>leave</code> animations if you want. For example, sometimes you may want an <code>enter</code> animation and no <code>leave</code> animation, but <code>ReactCSSTransitionGroup</code> waits for an animation to complete before removing your DOM node. You can add <code>transitionEnter={false}</code> or <code>transitionLeave={false}</code> props to <code>ReactCSSTransitionGroup</code> to disable these animations.</p> <blockquote>  <p>When using <code>ReactCSSTransitionGroup</code>, there's no way for your components to be notified when a transition has ended or to perform any more complex logic around animation. If you want more fine-grained control, you can use the lower-level <code>ReactTransitionGroup</code> API which provides the hooks you need to do custom transitions.</p> </blockquote>  <h2 id=\"low-level-api-reacttransitiongroup\">\nLow-level API: ReactTransitionGroup </h2> <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import ReactTransitionGroup from 'react-addons-transition-group' // ES6\nvar ReactTransitionGroup = require('react-addons-transition-group') // ES5 with npm\nvar ReactTransitionGroup = React.addons.TransitionGroup; // ES5 with react-with-addons.js</pre> <p><code>ReactTransitionGroup</code> is the basis for animations. When children are declaratively added or removed from it (as in the <a href=\"#getting-started\">example above</a>), special lifecycle hooks are called on them.</p> <ul> <li><a href=\"#componentwillappear\"><code>componentWillAppear()</code></a></li> <li><a href=\"#componentdidappear\"><code>componentDidAppear()</code></a></li> <li><a href=\"#componentwillenter\"><code>componentWillEnter()</code></a></li> <li><a href=\"#componentdidenter\"><code>componentDidEnter()</code></a></li> <li><a href=\"#componentwillleave\"><code>componentWillLeave()</code></a></li> <li><a href=\"#componentdidleave\"><code>componentDidLeave()</code></a></li> </ul> <h4 id=\"rendering-a-different-component\">\nRendering a Different Component </h4> <p><code>ReactTransitionGroup</code> renders as a <code>span</code> by default. You can change this behavior by providing a <code>component</code> prop. For example, here's how you would render a <code>&lt;ul&gt;</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component=\"ul\"&gt;\n  {/* ... */}\n&lt;/ReactTransitionGroup&gt;</pre> <p>Any additional, user-defined, properties will become properties of the rendered component. For example, here's how you would render a <code>&lt;ul&gt;</code> with CSS class:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component=\"ul\" className=\"animated-list\"&gt;\n  {/* ... */}\n&lt;/ReactTransitionGroup&gt;</pre> <p>Every DOM component that React can render is available for use. However, <code>component</code> does not need to be a DOM component. It can be any React component you want; even ones you've written yourself! Just write <code>component={List}</code> and your component will receive <code>this.props.children</code>.</p> <h4 id=\"rendering-a-single-child\">\nRendering a Single Child </h4> <p>People often use <code>ReactTransitionGroup</code> to animate mounting and unmounting of a single child such as a collapsible panel. Normally <code>ReactTransitionGroup</code> wraps all its children in a <code>span</code> (or a custom <code>component</code> as described above). This is because any React component has to return a single root element, and <code>ReactTransitionGroup</code> is no exception to this rule.</p> <p>However if you only need to render a single child inside <code>ReactTransitionGroup</code>, you can completely avoid wrapping it in a <code>&lt;span&gt;</code> or any other DOM component. To do this, create a custom component that renders the first child passed to it directly:</p> <pre class=\"highlight\" data-language=\"javascript\">function FirstChild(props) {\n  const childrenArray = React.Children.toArray(props.children);\n  return childrenArray[0] || null;\n}</pre> <p>Now you can specify <code>FirstChild</code> as the <code>component</code> prop in <code>&lt;ReactTransitionGroup&gt;</code> props and avoid any wrappers in the result DOM:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component={FirstChild}&gt;\n  {someCondition ? &lt;MyComponent /&gt; : null}\n&lt;/ReactTransitionGroup&gt;</pre> <p>This only works when you are animating a single child in and out, such as a collapsible panel. This approach wouldn't work when animating multiple children or replacing the single child with another child, such as an image carousel. For an image carousel, while the current image is animating out, another image will animate in, so <code>&lt;ReactTransitionGroup&gt;</code> needs to give them a common DOM parent. You can't avoid the wrapper for multiple children, but you can customize the wrapper with the <code>component</code> prop as described above.</p>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"componentwillappear\">\n<code>componentWillAppear()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillAppear(callback)</pre> <p>This is called at the same time as <code>componentDidMount()</code> for components that are initially mounted in a <code>TransitionGroup</code>. It will block other animations from occurring until <code>callback</code> is called. It is only called on the initial render of a <code>TransitionGroup</code>.</p>  <h3 id=\"componentdidappear\">\n<code>componentDidAppear()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentDidAppear()</pre> <p>This is called after the <code>callback</code> function that was passed to <code>componentWillAppear</code> is called.</p>  <h3 id=\"componentwillenter\">\n<code>componentWillEnter()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillEnter(callback)</pre> <p>This is called at the same time as <code>componentDidMount()</code> for components added to an existing <code>TransitionGroup</code>. It will block other animations from occurring until <code>callback</code> is called. It will not be called on the initial render of a <code>TransitionGroup</code>.</p>  <h3 id=\"componentdidenter\">\n<code>componentDidEnter()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentDidEnter()</pre> <p>This is called after the <code>callback</code> function that was passed to <a href=\"#componentwillenter\"><code>componentWillEnter()</code></a> is called.</p>  <h3 id=\"componentwillleave\">\n<code>componentWillLeave()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillLeave(callback)</pre> <p>This is called when the child has been removed from the <code>ReactTransitionGroup</code>. Though the child has been removed, <code>ReactTransitionGroup</code> will keep it in the DOM until <code>callback</code> is called.</p>  <h3 id=\"componentdidleave\">\n<code>componentDidLeave()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentDidLeave()</pre> <p>This is called when the <code>willLeave</code> <code>callback</code> is called (at the same time as <code>componentWillUnmount()</code>).</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/animation.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/animation.html</a>\n  </p>\n</div>\n","update":"<h1> Immutability Helpers </h1>  <blockquote> <p>Note: <code>update</code> is a legacy add-on. Use <a href=\"https://github.com/kolodny/immutability-helper\">kolodny/immutability-helper</a> instead.</p> </blockquote> <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import update from 'react-addons-update'; // ES6\nvar update = require('react-addons-update'); // ES5 with npm\nvar update = React.addons.update; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p>React lets you use whatever style of data management you want, including mutation. However, if you can use immutable data in performance-critical parts of your application it's easy to implement a fast <a href=\"react-component#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a> method to significantly speed up your app.</p> <p>Dealing with immutable data in JavaScript is more difficult than in languages designed for it, like <a href=\"http://clojure.org/\">Clojure</a>. However, we've provided a simple immutability helper, <code>update()</code>, that makes dealing with this type of data much easier, <em>without</em> fundamentally changing how your data is represented. You can also take a look at Facebook's <a href=\"https://facebook.github.io/immutable-js/docs/\">Immutable-js</a> and the <a href=\"optimizing-performance\">Advanced Performance</a> section for more detail on Immutable-js.</p> <h3 id=\"the-main-idea\">\nThe Main Idea </h3> <p>If you mutate data like this:</p> <pre class=\"highlight\" data-language=\"js\">myData.x.y.z = 7;\n// or...\nmyData.a.b.push(9);</pre> <p>You have no way of determining which data has changed since the previous copy has been overwritten. Instead, you need to create a new copy of <code>myData</code> and change only the parts of it that need to be changed. Then you can compare the old copy of <code>myData</code> with the new one in <code>shouldComponentUpdate()</code> using triple-equals:</p> <pre class=\"highlight\" data-language=\"js\">const newData = deepCopy(myData);\nnewData.x.y.z = 7;\nnewData.a.b.push(9);</pre> <p>Unfortunately, deep copies are expensive, and sometimes impossible. You can alleviate this by only copying objects that need to be changed and by reusing the objects that haven't changed. Unfortunately, in today's JavaScript this can be cumbersome:</p> <pre class=\"highlight\" data-language=\"js\">const newData = extend(myData, {\n  x: extend(myData.x, {\n    y: extend(myData.x.y, {z: 7}),\n  }),\n  a: extend(myData.a, {b: myData.a.b.concat(9)})\n});</pre> <p>While this is fairly performant (since it only makes a shallow copy of <code>log n</code> objects and reuses the rest), it's a big pain to write. Look at all the repetition! This is not only annoying, but also provides a large surface area for bugs.</p> <h2 id=\"update\">\n<code>update()</code> </h2> <p><code>update()</code> provides simple syntactic sugar around this pattern to make writing this code easier. This code becomes:</p> <pre class=\"highlight\" data-language=\"js\">import update from 'react-addons-update';\n\nconst newData = update(myData, {\n  x: {y: {z: {$set: 7}}},\n  a: {b: {$push: [9]}}\n});</pre> <p>While the syntax takes a little getting used to (though it's inspired by <a href=\"http://docs.mongodb.org/manual/core/crud-introduction/#query\">MongoDB's query language</a>) there's no redundancy, it's statically analyzable and it's not much more typing than the mutative version.</p> <p>The <code>$</code>-prefixed keys are called <em>commands</em>. The data structure they are \"mutating\" is called the <em>target</em>.</p> <h2 id=\"available-commands\">\nAvailable Commands </h2> <ul> <li>\n<code>{$push: array}</code> <code>push()</code> all the items in <code>array</code> on the target.</li> <li>\n<code>{$unshift: array}</code> <code>unshift()</code> all the items in <code>array</code> on the target.</li> <li>\n<code>{$splice: array of arrays}</code> for each item in <code>arrays</code> call <code>splice()</code> on the target with the parameters provided by the item.</li> <li>\n<code>{$set: any}</code> replace the target entirely.</li> <li>\n<code>{$merge: object}</code> merge the keys of <code>object</code> with the target.</li> <li>\n<code>{$apply: function}</code> passes in the current value to the function and updates it with the new returned value.</li> </ul> <h2 id=\"examples\">\nExamples </h2>\n<h3 id=\"simple-push\">\nSimple push </h3>\n<pre class=\"highlight\" data-language=\"js\">const initialArray = [1, 2, 3];\nconst newArray = update(initialArray, {$push: [4]}); // =&gt; [1, 2, 3, 4]</pre> <p><code>initialArray</code> is still <code>[1, 2, 3]</code>.</p> <h3 id=\"nested-collections\">\nNested collections </h3>\n<pre class=\"highlight\" data-language=\"js\">const collection = [1, 2, {a: [12, 17, 15]}];\nconst newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});\n// =&gt; [1, 2, {a: [12, 13, 14, 15]}]</pre> <p>This accesses <code>collection</code>'s index <code>2</code>, key <code>a</code>, and does a splice of one item starting from index <code>1</code> (to remove <code>17</code>) while inserting <code>13</code> and <code>14</code>.</p> <h3 id=\"updating-a-value-based-on-its-current-one\">\nUpdating a value based on its current one </h3>\n<pre class=\"highlight\" data-language=\"js\">const obj = {a: 5, b: 3};\nconst newObj = update(obj, {b: {$apply: function(x) {return x * 2;}}});\n// =&gt; {a: 5, b: 6}\n// This is equivalent, but gets verbose for deeply nested collections:\nconst newObj2 = update(obj, {b: {$set: obj.b * 2}});</pre>\n<h3 id=\"shallow-merge\">\n(Shallow) Merge </h3>\n<pre class=\"highlight\" data-language=\"js\">const obj = {a: 5, b: 3};\nconst newObj = update(obj, {$merge: {b: 6, c: 7}}); // =&gt; {a: 5, b: 6, c: 7}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/update.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/update.html</a>\n  </p>\n</div>\n","lifting-state-up":"<h1> Lifting State Up </h1>  <p>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let's see how this works in action.</p> <p>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</p> <p>We will start with a component called <code>BoilingVerdict</code>. It accepts the <code>celsius</code> temperature as a prop, and prints whether it is enough to boil the water:</p> <pre class=\"highlight\" data-language=\"js\">function BoilingVerdict(props) {\n  if (props.celsius &gt;= 100) {\n    return &lt;p&gt;The water would boil.&lt;/p&gt;;\n  }\n  return &lt;p&gt;The water would not boil.&lt;/p&gt;;\n}</pre> <p>Next, we will create a component called <code>Calculator</code>. It renders an <code>&lt;input&gt;</code> that lets you enter the temperature, and keeps its value in <code>this.state.value</code>.</p> <p>Additionally, it renders the <code>BoilingVerdict</code> for the current input value.</p> <pre class=\"highlight\" data-language=\"js\">class Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;\n        &lt;input\n          value={value}\n          onChange={this.handleChange} /&gt;\n        &lt;BoilingVerdict\n          celsius={parseFloat(value)} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/Gjxgrj?editors=0010\">Try it on CodePen.</a></p> <h2 id=\"adding-a-second-input\">\nAdding a Second Input </h2> <p>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</p> <p>We can start by extracting a <code>TemperatureInput</code> component from <code>Calculator</code>. We will add a new <code>scale</code> prop to it that can either be <code>\"c\"</code> or <code>\"f\"</code>:</p> <pre class=\"highlight\" data-language=\"js\">const scaleNames = {\n  c: 'Celsius',\n  f: 'Fahrenheit'\n};\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={value}\n               onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}</pre> <p>We can now change the <code>Calculator</code> to render two separate temperature inputs:</p> <pre class=\"highlight\" data-language=\"js\">class Calculator extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput scale=\"c\" /&gt;\n        &lt;TemperatureInput scale=\"f\" /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/NRrzOL?editors=0010\">Try it on CodePen.</a></p> <p>We have two inputs now, but when you enter the temperature in one of them, the other doesn't update. This contradicts our requirement: we want to keep them in sync.</p> <p>We also can't display the <code>BoilingVerdict</code> from <code>Calculator</code>. The <code>Calculator</code> doesn't know the current temperature because it is hidden inside the <code>TemperatureInput</code>.</p> <h2 id=\"lifting-state-up\">\nLifting State Up </h2> <p>First, we will write two functions to convert from Celsius to Fahrenheit and back:</p> <pre class=\"highlight\" data-language=\"js\">function toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}</pre> <p>These two functions convert numbers. We will write another function that takes a string <code>value</code> and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</p> <p>It returns an empty string on an invalid <code>value</code>, and it keeps the output rounded to the third decimal place:</p> <pre class=\"highlight\" data-language=\"js\">function tryConvert(value, convert) {\n  const input = parseFloat(value);\n  if (Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}</pre> <p>For example, <code>tryConvert('abc', toCelsius)</code> returns an empty string, and <code>tryConvert('10.22', toFahrenheit)</code> returns <code>'50.396'</code>.</p> <p>Next, we will remove the state from <code>TemperatureInput</code>.</p> <p>Instead, it will receive both <code>value</code> and the <code>onChange</code> handler by props:</p> <pre class=\"highlight\" data-language=\"js\">class TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onChange(e.target.value);\n  }\n\n  render() {\n    const value = this.props.value;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={value}\n               onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}</pre> <p>If several components need access to the same state, it is a sign that the state should be lifted up to their closest common ancestor instead. In our case, this is the <code>Calculator</code>. We will store the current <code>value</code> and <code>scale</code> in its state.</p> <p>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current <code>value</code> and <code>scale</code> alone.</p> <p>The inputs stay in sync because their values are computed from the same state:</p> <pre class=\"highlight\" data-language=\"js\">class Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {value: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(value) {\n    this.setState({scale: 'c', value});\n  }\n\n  handleFahrenheitChange(value) {\n    this.setState({scale: 'f', value});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const value = this.state.value;\n    const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;\n    const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;\n\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput\n          scale=\"c\"\n          value={celsius}\n          onChange={this.handleCelsiusChange} /&gt;\n        &lt;TemperatureInput\n          scale=\"f\"\n          value={fahrenheit}\n          onChange={this.handleFahrenheitChange} /&gt;\n        &lt;BoilingVerdict\n          celsius={parseFloat(celsius)} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/ozdyNg?editors=0010\">Try it on CodePen.</a></p> <p>Now, no matter which input you edit, <code>this.state.value</code> and <code>this.state.scale</code> in the <code>Calculator</code> get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</p> <h2 id=\"lessons-learned\">\nLessons Learned </h2> <p>There should be a single \"source of truth\" for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the <a href=\"state-and-lifecycle#the-data-flows-down\">top-down data flow</a>.</p> <p>Lifting state involves writing more \"boilerplate\" code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state \"lives\" in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</p> <p>If something can be derived from either props or state, it probably shouldn't be in the state. For example, instead of storing both <code>celsiusValue</code> and <code>fahrenheitValue</code>, we store just the last edited <code>value</code> and its <code>scale</code>. The value of the other input can always be calculated from them in the <code>render()</code> method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</p> <p>When you see something wrong in the UI, you can use <a href=\"https://github.com/facebook/react-devtools\">React Developer Tools</a> to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</p> <p><img src=\"https://facebook.github.io/react/img/docs/react-devtools-state.gif\" alt=\"Monitoring State in React DevTools\" width=\"100%\"></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/lifting-state-up.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/lifting-state-up.html</a>\n  </p>\n</div>\n","components-and-props":"<h1> Components and Props </h1>  <p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p> <p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called \"props\") and return React elements describing what should appear on the screen.</p> <h2 id=\"functional-and-class-components\">\nFunctional and Class Components </h2> <p>The simplest way to define a component is to write a JavaScript function:</p> <pre class=\"highlight\" data-language=\"js\">function Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;\n}</pre> <p>This function is a valid React component because it accepts a single \"props\" object argument with data and returns a React element. We call such components \"functional\" because they are literally JavaScript functions.</p> <p>You can also use an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 class</a> to define a component:</p> <pre class=\"highlight\" data-language=\"js\">class Welcome extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}</pre> <p>The above two components are equivalent from React's point of view.</p> <p>Classes have some additional features that we will discuss in the <a href=\"state-and-lifecycle\">next sections</a>. Until then, we will use functional components for their conciseness.</p> <h2 id=\"rendering-a-component\">\nRendering a Component </h2> <p>Previously, we only encountered React elements that represent DOM tags:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;div /&gt;;</pre> <p>However, elements can also represent user-defined components:</p> <pre class=\"highlight\" data-language=\"js\">const element = &lt;Welcome name=\"Sara\" /&gt;;</pre> <p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object \"props\".</p> <p>For example, this code renders \"Hello, Sara\" on the page:</p> <pre class=\"highlight\" data-language=\"js\">function Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;\n}\n\nconst element = &lt;Welcome name=\"Sara\" /&gt;;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/YGYmEG?editors=0010\">Try it on CodePen.</a></p> <p>Let's recap what happens in this example:</p> <ol> <li>We call <code>ReactDOM.render()</code> with the <code>&lt;Welcome name=\"Sara\" /&gt;</code> element.</li> <li>React calls the <code>Welcome</code> component with <code>{name: 'Sara'}</code> as the props.</li> <li>Our <code>Welcome</code> component returns a <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> element as the result.</li> <li>React DOM efficiently updates the DOM to match <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>.</li> </ol> <blockquote> <p><strong>Caveat:</strong></p> <p>Always start component names with a capital letter.</p> <p>For example, <code>&lt;div /&gt;</code> represents a DOM tag, but <code>&lt;Welcome /&gt;</code> represents a component and requires <code>Welcome</code> to be in scope.</p> </blockquote> <h2 id=\"composing-components\">\nComposing Components </h2> <p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p> <p>For example, we can create an <code>App</code> component that renders <code>Welcome</code> many times:</p> <pre class=\"highlight\" data-language=\"js\">function Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Welcome name=\"Sara\" /&gt;\n      &lt;Welcome name=\"Cahal\" /&gt;\n      &lt;Welcome name=\"Edite\" /&gt;\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(\n  &lt;App /&gt;,\n  document.getElementById('root')\n);</pre> <p><a href=\"http://codepen.io/gaearon/pen/KgQKPr?editors=0010\">Try it on CodePen.</a></p> <p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p> <blockquote> <p><strong>Caveat:</strong></p> <p>Components must return a single root element. This is why we added a <code>&lt;div&gt;</code> to contain all the <code>&lt;Welcome /&gt;</code> elements.</p> </blockquote> <h2 id=\"extracting-components\">\nExtracting Components </h2> <p>Don't be afraid to split components into smaller components.</p> <p>For example, consider this <code>Comment</code> component:</p> <pre class=\"highlight\" data-language=\"js\">function Comment(props) {\n  return (\n    &lt;div className=\"Comment\"&gt;\n      &lt;div className=\"UserInfo\"&gt;\n        &lt;img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        /&gt;\n        &lt;div className=\"UserInfo-name\"&gt;\n          {props.author.name}\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=\"Comment-text\"&gt;\n        {props.text}\n      &lt;/div&gt;\n      &lt;div className=\"Comment-date\"&gt;\n        {formatDate(props.date)}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/VKQwEo?editors=0010\">Try it on CodePen.</a></p> <p>It accepts <code>author</code> (an object), <code>text</code> (a string), and <code>date</code> (a date) as props, and describes a comment on a social media website.</p> <p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let's extract a few components from it.</p> <p>First, we will extract <code>Avatar</code>:</p> <pre class=\"highlight\" data-language=\"js\">function Avatar(props) {\n  return (\n    &lt;img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    /&gt;\n  );\n}</pre> <p>The <code>Avatar</code> doesn't need to know that it is being rendered inside a <code>Comment</code>. This is why we have given its prop a more generic name: <code>user</code> rather than <code>author</code>.</p> <p>We recommend naming props from the component's own point of view rather than the context in which it is being used.</p> <p>We can now simplify <code>Comment</code> a tiny bit:</p> <pre class=\"highlight\" data-language=\"js\">function Comment(props) {\n  return (\n    &lt;div className=\"Comment\"&gt;\n      &lt;div className=\"UserInfo\"&gt;\n        &lt;Avatar user={props.author} /&gt;\n        &lt;div className=\"UserInfo-name\"&gt;\n          {props.author.name}\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=\"Comment-text\"&gt;\n        {props.text}\n      &lt;/div&gt;\n      &lt;div className=\"Comment-date\"&gt;\n        {formatDate(props.date)}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre> <p>Next, we will extract a <code>UserInfo</code> component that renders an <code>Avatar</code> next to user's name:</p> <pre class=\"highlight\" data-language=\"js\">function UserInfo(props) {\n  return (\n    &lt;div className=\"UserInfo\"&gt;\n      &lt;Avatar user={props.user} /&gt;\n      &lt;div className=\"UserInfo-name\"&gt;\n        {props.user.name}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre> <p>This lets us simplify <code>Comment</code> even further:</p> <pre class=\"highlight\" data-language=\"js\">function Comment(props) {\n  return (\n    &lt;div className=\"Comment\"&gt;\n      &lt;UserInfo user={props.author} /&gt;\n      &lt;div className=\"Comment-text\"&gt;\n        {props.text}\n      &lt;/div&gt;\n      &lt;div className=\"Comment-date\"&gt;\n        {formatDate(props.date)}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre> <p><a href=\"http://codepen.io/gaearon/pen/rrJNJY?editors=0010\">Try it on CodePen.</a></p> <p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (<code>Button</code>, <code>Panel</code>, <code>Avatar</code>), or is complex enough on its own (<code>App</code>, <code>FeedStory</code>, <code>Comment</code>), it is a good candidate to be a reusable component.</p> <h2 id=\"props-are-read-only\">\nProps are Read-Only </h2> <p>Whether you declare a component <a href=\"#functional-and-class-components\">as a function or a class</a>, it must never modify its own props. Consider this <code>sum</code> function:</p> <pre class=\"highlight\" data-language=\"js\">function sum(a, b) {\n  return a + b;\n}</pre> <p>Such functions are called <a href=\"https://en.wikipedia.org/wiki/Pure_function\">\"pure\"</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p> <p>In contrast, this function is impure because it changes its own input:</p> <pre class=\"highlight\" data-language=\"js\">function withdraw(account, amount) {\n  account.total -= amount;\n}</pre> <p>React is pretty flexible but it has a single strict rule:</p> <p><strong>All React components must act like pure functions with respect to their props.</strong></p> <p>Of course, application UIs are dynamic and change over time. In the <a href=\"state-and-lifecycle\">next section</a>, we will introduce a new concept of \"state\". State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/components-and-props.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/components-and-props.html</a>\n  </p>\n</div>\n","optimizing-performance":"<h1> Optimizing Performance </h1>  <p>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</p> <h2 id=\"use-the-production-build\">\nUse The Production Build </h2> <p>If you're benchmarking or experiencing performance problems in your React apps, make sure you're testing with the minified production build:</p> <ul> <li>For Create React App, you need to run <code>npm run build</code> and follow the instructions.</li> <li>For single-file builds, we offer production-ready <code>.min.js</code> versions.</li> <li>For Browserify, you need to run it with <code>NODE_ENV=production</code>.</li> <li>For Webpack, you need to add this to plugins in your production config:</li> </ul> <pre class=\"highlight\" data-language=\"js\">new webpack.DefinePlugin({\n  'process.env': {\n    NODE_ENV: JSON.stringify('production')\n  }\n}),\nnew webpack.optimize.UglifyJsPlugin()</pre> <p>The development build includes extra warnings that are helpful when building your apps, but it is slower due to the extra bookkeeping it does.</p> <h2 id=\"profiling-components-with-chrome-timeline\">\nProfiling Components with Chrome Timeline </h2> <p>In the <strong>development</strong> mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</p> \n<center><img src=\"https://facebook.github.io/react/img/blog/react-perf-chrome-timeline.png\" width=\"651\" height=\"228\" alt=\"React components in Chrome timeline\"></center> <p>To do this in Chrome:</p> <ol> <li><p>Load your app with <code>?react_perf</code> in the query string (for example, <code>http://localhost:3000/?react_perf</code>).</p></li> <li><p>Open the Chrome DevTools <strong><a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool\">Timeline</a></strong> tab and press <strong>Record</strong>.</p></li> <li><p>Perform the actions you want to profile. Don't record more than 20 seconds or Chrome might hang.</p></li> <li><p>Stop recording.</p></li> <li><p>React events will be grouped under the <strong>User Timing</strong> label.</p></li> </ol> <p>Note that <strong>the numbers are relative so components will render faster in production</strong>. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</p> <p>Currently Chrome, Edge, and IE are the only browsers supporting this feature, but we use the standard <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API\">User Timing API</a> so we expect more browsers to add support for it.</p> <h2 id=\"avoid-reconciliation\">\nAvoid Reconciliation </h2> <p>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a \"virtual DOM\", but it works the same way on React Native.</p> <p>When a component's props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.</p> <p>In some cases, your component can speed all of this up by overriding the lifecycle function <code>shouldComponentUpdate</code>, which is triggered before the re-rendering process starts. The default implementation of this function returns <code>true</code>, leaving React to perform the update:</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate(nextProps, nextState) {\n  return true;\n}</pre> <p>If you know that in some situations your component doesn't need to update, you can return <code>false</code> from <code>shouldComponentUpdate</code> instead, to skip the whole rendering process, including calling <code>render()</code> on this component and below.</p> <h2 id=\"shouldcomponentupdate-in-action\">\nshouldComponentUpdate In Action </h2> <p>Here's a subtree of components. For each one, <code>SCU</code> indicates what <code>shouldComponentUpdate</code> returned, and <code>vDOMEq</code> indicates whether the rendered React elements were equivalent. Finally, the circle's color indicates whether the component had to be reconciled or not.</p> <figure><img src=\"https://facebook.github.io/react/img/docs/should-component-update.png\"></figure> <p>Since <code>shouldComponentUpdate</code> returned <code>false</code> for the subtree rooted at C2, React did not attempt to render C2, and thus didn't even have to invoke <code>shouldComponentUpdate</code> on C4 and C5.</p> <p>For C1 and C3, <code>shouldComponentUpdate</code> returned <code>true</code>, so React had to go down to the leaves and check them. For C6 <code>shouldComponentUpdate</code> returned <code>true</code>, and since the rendered elements weren't equivalent React had to update the DOM.</p> <p>The last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn't have to update the DOM.</p> <p>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2's subtree and C7, it didn't even have to compare the elements as we bailed out on <code>shouldComponentUpdate</code>, and <code>render</code> was not called.</p> <h2 id=\"examples\">\nExamples </h2> <p>If the only way your component ever changes is when the <code>props.color</code> or the <code>state.count</code> variable changes, you could have <code>shouldComponentUpdate</code> check that:</p> <pre class=\"highlight\" data-language=\"javascript\">class CounterButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.color !== nextProps.color) {\n      return true;\n    }\n    if (this.state.count !== nextState.count) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    return (\n      &lt;button\n        color={this.props.color}\n        onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}&gt;\n        Count: {this.state.count}\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>In this code, <code>shouldComponentUpdate</code> is just checking if there is any change in <code>props.color</code> or <code>state.count</code>. If those values don't change, the component doesn't update. If your component got more complex, you could use a similar pattern of doing a \"shallow comparison\" between all the fields of <code>props</code> and <code>state</code> to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from <code>React.PureComponent</code>. So this code is a simpler way to achieve the same thing:</p> <pre class=\"highlight\" data-language=\"js\">class CounterButton extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  render() {\n    return (\n      &lt;button\n        color={this.props.color}\n        onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}&gt;\n        Count: {this.state.count}\n      &lt;/button&gt;\n    );\n  }\n}</pre> <p>Most of the time, you can use <code>React.PureComponent</code> instead of writing your own <code>shouldComponentUpdate</code>. It only does a shallow comparison, so you can't use it if the props or state may have been mutated in a way that a shallow comparison would miss.</p> <p>This can be a problem with more complex data structures. For example, let's say you want a <code>ListOfWords</code> component to render a comma-separated list of words, with a parent <code>WordAdder</code> component that lets you click a button to add a word to the list. This code does <em>not</em> work correctly:</p> <pre class=\"highlight\" data-language=\"javascript\">class ListOfWords extends React.PureComponent {\n  render() {\n    return &lt;div&gt;{this.props.words.join(',')}&lt;/div&gt;;\n  }\n}\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: ['marklar']\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // This section is bad style and causes a bug\n    const words = this.state.words;\n    words.push('marklar');\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleClick} /&gt;\n        &lt;ListOfWords words={this.state.words} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</pre> <p>The problem is that <code>PureComponent</code> will do a simple comparison between the old and new values of <code>this.props.words</code>. Since this code mutates the <code>words</code> array in the <code>handleClick</code> method of <code>WordAdder</code>, the old and new values of <code>this.props.words</code> will compare as equal, even though the actual words in the array have changed. The <code>ListOfWords</code> will thus not update even though it has new words that shoud be rendered.</p> <h2 id=\"the-power-of-not-mutating-data\">\nThe Power Of Not Mutating Data </h2> <p>The simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the <code>handleClick</code> method above could be rewritten using <code>concat</code> as:</p> <pre class=\"highlight\" data-language=\"javascript\">handleClick() {\n  this.setState(prevState =&gt; ({\n    words: prevState.words.concat(['marklar'])\n  }));\n}</pre> <p>ES6 supports a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\">spread syntax</a> for arrays which can make this easier. If you're using Create React App, this syntax is available by default.</p> <pre class=\"highlight\" data-language=\"js\">handleClick() {\n  this.setState(prevState =&gt; ({\n    words: [...prevState.words, 'marklar'],\n  }));\n};</pre> <p>You can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let's say we have an object named <code>colormap</code> and we want to write a function that changes <code>colormap.right</code> to be <code>'blue'</code>. We could write:</p> <pre class=\"highlight\" data-language=\"js\">function updateColorMap(colormap) {\n  colormap.right = 'blue';\n}</pre> <p>To write this without mutating the original object, we can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\">Object.assign</a> method:</p> <pre class=\"highlight\" data-language=\"js\">function updateColorMap(colormap) {\n  return Object.assign({}, colormap, {right: 'blue'});\n}</pre> <p><code>updateColorMap</code> now returns a new object, rather than mutating the old one. <code>Object.assign</code> is in ES6 and requires a polyfill.</p> <p>There is a JavaScript proposal to add <a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\">object spread properties</a> to make it easier to update objects without mutation as well:</p> <pre class=\"highlight\" data-language=\"js\">function updateColorMap(colormap) {\n  return {...colormap, right: 'blue'};\n}</pre> <p>If you're using Create React App, both <code>Object.assign</code> and the object spread syntax are available by default.</p> <h2 id=\"using-immutable-data-structures\">\nUsing Immutable Data Structures </h2> <p><a href=\"https://github.com/facebook/immutable-js\">Immutable.js</a> is another way to solve this problem. It provides immutable, persistent collections that work via structural sharing:</p> <ul> <li>\n<em>Immutable</em>: once created, a collection cannot be altered at another point in time.</li> <li>\n<em>Persistent</em>: new collections can be created from a previous collection and a mutation such as set. The original collection is still valid after the new collection is created.</li> <li>\n<em>Structural Sharing</em>: new collections are created using as much of the same structure as the original collection as possible, reducing copying to a minimum to improve performance.</li> </ul> <p>Immutability makes tracking changes cheap. A change will always result in a new object so we only need to check if the reference to the object has changed. For example, in this regular JavaScript code:</p> <pre class=\"highlight\" data-language=\"javascript\">const x = { foo: \"bar\" };\nconst y = x;\ny.foo = \"baz\";\nx === y; // true</pre> <p>Although <code>y</code> was edited, since it's a reference to the same object as <code>x</code>, this comparison returns <code>true</code>. You can write similar code with immutable.js:</p> <pre class=\"highlight\" data-language=\"javascript\">const SomeRecord = Immutable.Record({ foo: null });\nconst x = new SomeRecord({ foo: 'bar'  });\nconst y = x.set('foo', 'baz');\nx === y; // false</pre> <p>In this case, since a new reference is returned when mutating <code>x</code>, we can safely assume that <code>x</code> has changed.</p> <p>Two other libraries that can help use immutable data are <a href=\"https://github.com/rtfeldman/seamless-immutable\">seamless-immutable</a> and <a href=\"https://github.com/kolodny/immutability-helper\">immutability-helper</a>.</p> <p>Immutable data structures provide you with a cheap way to track changes on objects, which is all we need to implement <code>shouldComponentUpdate</code>. This can often provide you with a nice performance boost.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/optimizing-performance.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/optimizing-performance.html</a>\n  </p>\n</div>\n","context":"<h1> Context </h1>  <p>With React, it's easy to track the flow of data through your React components. When you look at a component, you can see which props are being passed, which makes your apps easy to reason about.</p> <p>In some cases, you want to pass data through the component tree without having to pass the props down manually at every level. You can do this directly in React with the powerful \"context\" API.</p> <h2 id=\"why-not-to-use-context\">\nWhy Not To Use Context </h2> <p>The vast majority of applications do not need to use context.</p> <p>If you want your application to be stable, don't use context. It is an experimental API and it is likely to break in future releases of React.</p> <p>If you aren't familiar with state management libraries like <a href=\"https://github.com/reactjs/redux\">Redux</a> or <a href=\"https://github.com/mobxjs/mobx\">MobX</a>, don't use context. For many practical applications, these libraries and their React bindings are a good choice for managing state that is relevant to many components. It is far more likely that Redux is the right solution to your problem than that context is the right solution.</p> <p>If you aren't an experienced React developer, don't use context. There is usually a better way to implement functionality just using props and state.</p> <p>If you insist on using context despite these warnings, try to isolate your use of context to a small area and avoid using the context API directly when possible so that it's easier to upgrade when the API changes.</p> <h2 id=\"how-to-use-context\">\nHow To Use Context </h2> <p>Suppose you have a structure like:</p> <pre class=\"highlight\" data-language=\"javascript\">class Button extends React.Component {\n  render() {\n    return (\n      &lt;button style={{background: this.props.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nclass Message extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button color={this.props.color}&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  render() {\n    const color = \"purple\";\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} color={color} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}</pre> <p>In this example, we manually thread through a <code>color</code> prop in order to style the <code>Button</code> and <code>Message</code> components appropriately. Using context, we can pass this through the tree automatically:</p> <pre class=\"highlight\" data-language=\"javascript\">class Button extends React.Component {\n  render() {\n    return (\n      &lt;button style={{background: this.context.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: React.PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: React.PropTypes.string\n};</pre> <p>By adding <code>childContextTypes</code> and <code>getChildContext</code> to <code>MessageList</code> (the context provider), React passes the information down automatically and any component in the subtree (in this case, <code>Button</code>) can access it by defining <code>contextTypes</code>.</p> <p>If <code>contextTypes</code> is not defined, then <code>context</code> will be an empty object.</p> <h2 id=\"parent-child-coupling\">\nParent-Child Coupling </h2> <p>Context can also let you build an API where parents and children communicate. For example, one library that works this way is <a href=\"https://react-router.now.sh/basic\">React Router V4</a>:</p> <pre class=\"highlight\" data-language=\"javascript\">const BasicExample = () =&gt; (\n  &lt;Router&gt;\n    &lt;div&gt;\n      &lt;ul&gt;\n        &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt;&lt;/li&gt;\n      &lt;/ul&gt;\n\n      &lt;hr/&gt;\n\n      &lt;Match exactly pattern=\"/\" component={Home} /&gt;\n      &lt;Match pattern=\"/about\" component={About} /&gt;\n      &lt;Match pattern=\"/topics\" component={Topics} /&gt;\n    &lt;/div&gt;\n  &lt;/Router&gt;\n)</pre> <p>By passing down some information from the <code>Router</code> component, each <code>Link</code> and <code>Match</code> can communicate back to the containing <code>Router</code>.</p> <p>Before you build components with an API similar to this, consider if there are cleaner alternatives. For example, you can pass entire React component as props if you'd like to.</p> <h2 id=\"referencing-context-in-lifecycle-methods\">\nReferencing Context in Lifecycle Methods </h2> <p>If <code>contextTypes</code> is defined within a component, the following <a href=\"react-component#the-component-lifecycle\">lifecycle methods</a> will receive an additional parameter, the <code>context</code> object:</p> <ul> <li><a href=\"react-component#constructor\"><code>constructor(props, context)</code></a></li> <li><a href=\"react-component#componentwillreceiveprops\"><code>componentWillReceiveProps(nextProps, nextContext)</code></a></li> <li><a href=\"react-component#shouldcomponentupdate\"><code>shouldComponentUpdate(nextProps, nextState, nextContext)</code></a></li> <li><a href=\"react-component#componentwillupdate\"><code>componentWillUpdate(nextProps, nextState, nextContext)</code></a></li> <li><a href=\"react-component#componentdidupdate\"><code>componentDidUpdate(prevProps, prevState, prevContext)</code></a></li> </ul> <h2 id=\"referencing-context-in-stateless-functional-components\">\nReferencing Context in Stateless Functional Components </h2> <p>Stateless functional components are also able to reference <code>context</code> if <code>contextTypes</code> is defined as a property of the function. The following code shows a <code>Button</code> component written as a stateless functional component.</p> <pre class=\"highlight\" data-language=\"javascript\">const Button = ({children}, context) =&gt;\n  &lt;button style={{background: context.color}}&gt;\n    {children}\n  &lt;/button&gt;;\n\nButton.contextTypes = {color: React.PropTypes.string};</pre>\n<h2 id=\"updating-context\">\nUpdating Context </h2> <p>Don't do it.</p> <p>React has an API to update context, but it is fundamentally broken and you should not use it.</p> <p>The <code>getChildContext</code> function will be called when the state or props changes. In order to update data in the context, trigger a local state update with <code>this.setState</code>. This will trigger a new context and changes will be received by the children.</p> <pre class=\"highlight\" data-language=\"javascript\">class MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () =&gt; {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: React.PropTypes.string\n};</pre> <p>The problem is, if a context value provided by component changes, descendants that use that value won't update if an intermediate parent returns <code>false</code> from <code>shouldComponentUpdate</code>. This is totally out of control of the components using context, so there's basically no way to reliably update the context. <a href=\"https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076\">This blog post</a> has a good explanation of why this is a problem and how you might get around it.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/context.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/context.html</a>\n  </p>\n</div>\n","pure-render-mixin":"<h1> PureRenderMixin </h1>  <blockquote> <p>Note</p> <p>The <code>PureRenderMixin</code> mixin predates <code>React.PureComponent</code>. This reference doc is provided for legacy purposes, and you should consider using <a href=\"react-api#react.purecomponent\"><code>React.PureComponent</code></a> instead.</p> </blockquote> <p>If your React component's render function renders the same result given the same props and state, you can use this mixin for a performance boost in some cases.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"js\">var PureRenderMixin = require('react-addons-pure-render-mixin');\nReact.createClass({\n  mixins: [PureRenderMixin],\n\n  render: function() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n});</pre> <p>Example using ES6 class syntax:</p> <pre class=\"highlight\" data-language=\"js\">import PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}</pre> <p>Under the hood, the mixin implements <a href=\"react-component#updating-shouldcomponentupdate\">shouldComponentUpdate</a>, in which it compares the current props and state with the next ones and returns <code>false</code> if the equalities pass.</p> <blockquote>  <p>This only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only mix into components which have simple props and state, or use <code>forceUpdate()</code> when you know deep data structures have changed. Or, consider using <a href=\"https://facebook.github.io/immutable-js/\">immutable objects</a> to facilitate fast comparisons of nested data.</p> <p>Furthermore, <code>shouldComponentUpdate</code> skips updates for the whole component subtree. Make sure all the children components are also \"pure\".</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/pure-render-mixin.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/pure-render-mixin.html</a>\n  </p>\n</div>\n","shallow-compare":"<h1> Shallow Compare </h1>  <blockquote> <p>Note: <code>shallowCompare</code> is a legacy add-on. Use <a href=\"react-api#react.purecomponent\"><code>React.PureComponent</code></a> instead.</p> </blockquote> <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import shallowCompare from 'react-addons-shallow-compare' // ES6\nvar shallowCompare = require('react-addons-shallow-compare') // ES5 with npm\nvar shallowCompare = React.addons.shallowCompare; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p>Before <a href=\"react-api#react.purecomponent\"><code>React.PureComponent</code></a> was introduced, <code>shallowCompare</code> was commonly used to achieve the same functionality as <a href=\"pure-render-mixin\"><code>PureRenderMixin</code></a> while using ES6 classes with React.</p> <p>If your React component's render function is \"pure\" (in other words, it renders the same result given the same props and state), you can use this helper function for a performance boost in some cases.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"js\">export class SampleComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return shallowCompare(this, nextProps, nextState);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}</pre> <p><code>shallowCompare</code> performs a shallow equality check on the current <code>props</code> and <code>nextProps</code> objects as well as the current <code>state</code> and <code>nextState</code> objects.<br> It does this by iterating on the keys of the objects being compared and returning true when the values of a key in each object are not strictly equal.</p> <p><code>shallowCompare</code> returns <code>true</code> if the shallow comparison for props or state fails and therefore the component should update.<br> <code>shallowCompare</code> returns <code>false</code> if the shallow comparison for props and state both pass and therefore the component does not need to update.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/shallow-compare.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/shallow-compare.html</a>\n  </p>\n</div>\n","higher-order-components":"<h1> Higher-Order Components </h1>  <p>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React's compositional nature.</p> <p>Concretely, <strong>a higher-order component is a function that takes a component and returns a new component.</strong></p> <pre class=\"highlight\" data-language=\"js\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</pre> <p>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</p> <p>HOCs are common in third-party React libraries, such as Redux's <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\"><code>connect</code></a> and Relay's <a href=\"https://facebook.github.io/relay/docs/api-reference-relay.html#createcontainer-static-method\"><code>createContainer</code></a>.</p> <p>In this document, we'll discuss why higher-order components are useful, and how to write your own.</p> <h2 id=\"use-hocs-for-cross-cutting-concerns\">\nUse HOCs For Cross-Cutting Concerns </h2> <blockquote> <p><strong>Note</strong></p> <p>We previously recommended mixins as a way to handle cross-cutting concerns. We've since realized that mixins create more trouble than they are worth. <a href=\"https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html\">Read more</a> about why we've moved away from mixins and how you can transition your existing components.</p> </blockquote> <p>Components are the primary unit of code reuse in React. However, you'll find that some patterns aren't a straightforward fit for traditional components.</p> <p>For example, say you have a <code>CommentList</code> component that subscribes to an external data source to render a list of comments:</p> <pre class=\"highlight\" data-language=\"js\">class CommentList extends React.Component {\n  constructor() {\n    super();\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      // \"DataSource\" is some global data source\n      comments: DataSource.getComments()\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to changes\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    // Clean up listener\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    // Update component state whenever the data source changes\n    this.setState({\n      comments: DataSource.getComments()\n    });\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        {this.state.comments.map((comment) =&gt; (\n          &lt;Comment comment={comment} key={comment.id} /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }}</pre> <p>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</p> <pre class=\"highlight\" data-language=\"js\">class BlogPost extends React.Component {\n  constructor() {\n    super();\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return &lt;BlogPost blogPost={this.state.blogPost} /&gt;;\n  }}</pre> <p><code>CommentList</code> and <code>BlogPost</code> aren't identical — they call different methods on <code>DataSource</code>, and they render different output. But much of their implementation is the same:</p> <ul> <li>On mount, add a change listener to <code>DataSource</code>.</li> <li>Inside the listener, call <code>setState</code> whenever the data source changes.</li> <li>On unmount, remove the change listener.</li> </ul> <p>You can imagine that in a large app, this same pattern of subscribing to <code>DataSource</code> and calling <code>setState</code> will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share them across many components. This is where higher-order components excel.</p> <p>We can write a function that creates components, like <code>CommentList</code> and <code>BlogPost</code>, that subscribe to <code>DataSource</code>. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let's call the function <code>withSubscription</code>:</p> <pre class=\"highlight\" data-language=\"js\">const CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) =&gt; DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)\n});</pre> <p>The first parameter is the wrapped component. The second parameter retrieves the data we're interested in, given a <code>DataSource</code> and the current props.</p> <p>When <code>CommentListWithSubscription</code> and <code>BlogPostWithSubscription</code> are rendered, <code>CommentList</code> and <code>BlogPost</code> will be passed a <code>data</code> prop with the most current data retrieved from <code>DataSource</code>:</p> <pre class=\"highlight\" data-language=\"js\">// This function takes a component...\nfunction withSubscription(WrappedComponent, selectData) {\n  // ...and returns another component...\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ... that takes care of the subscription...\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ... and renders the wrapped component with the fresh data!\n      // Notice that we pass through any additional props\n      return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;\n    }\n  });\n}</pre> <p>Note that an HOC doesn't modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC <em>composes</em> the original component by <em>wrapping</em> it in a container component. An HOC is a pure function with zero side-effects.</p> <p>And that's it! The wrapped component receives all the props of the container, along with a new prop, <code>data</code>, which it uses to render its output. The HOC isn't concerned with how or why the data is used, and the wrapped component isn't concerned with where the data came from.</p> <p>Because <code>withSubscription</code> is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the <code>data</code> prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures <code>shouldComponentUpdate</code>, or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.</p> <p>Like components, the contract between <code>withSubscription</code> and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</p> <h2 id=\"dont-mutate-the-original-component.-use-composition.\">\nDon't Mutate the Original Component. Use Composition. </h2> <p>Resist the temptation to modify a component's prototype (or otherwise mutate it) inside an HOC.</p> <pre class=\"highlight\" data-language=\"js\">function logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  }\n  // The fact that we're returning the original input is a hint that it has\n  // been mutated.\n  return InputComponent;\n}\n\n// EnhancedComponent will log whenever props are received\nconst EnhancedComponent = logProps(InputComponent);</pre> <p>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to <code>EnhancedComponent</code> that <em>also</em> mutates <code>componentWillReceiveProps</code>, the first HOC's functionality will be overridden! This HOC also won't work with function components, which do not have lifecycle methods.</p> <p>Mutating HOCs are a leaky abstraction—the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</p> <p>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</p> <pre class=\"highlight\" data-language=\"js\">function logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // Wraps the input component in a container, without mutating it. Good!\n      return &lt;WrappedComponent {...this.props} /&gt;;\n    }\n  }\n}</pre> <p>This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it's a pure function, it's composable with other HOCs, or even with itself.</p> <p>You may have noticed similarities between HOCs and a pattern called <strong>container components</strong>. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</p> <h2 id=\"convention-pass-unrelated-props-through-to-the-wrapped-component\">\nConvention: Pass Unrelated Props Through to the Wrapped Component </h2> <p>HOCs add features to a component. They shouldn't drastically alter its contract. It's expected that the component returned from an HOC has a similar interface to the wrapped component.</p> <p>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</p> <pre class=\"highlight\" data-language=\"js\">render() {\n  // Filter out extra props that are specific to this HOC and shouldn't be\n  // passed through\n  const { extraProp, ...passThroughProps } = this.props;\n\n  // Inject props into the wrapped component. These are usually state values or\n  // instance methods.\n  const injectedProp = someStateOrInstanceMethod;\n\n  // Pass props to wrapped component\n  return (\n    &lt;WrappedComponent\n      injectedProp={injectedProp}\n      {...passThroughProps}\n    /&gt;\n  );\n}</pre> <p>This convention helps ensure that HOCs are as flexible and reusable as possible.</p> <h2 id=\"convention-maximizing-composability\">\nConvention: Maximizing Composability </h2> <p>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</p> <pre class=\"highlight\" data-language=\"js\">const NavbarWithRouter = withRouter(Navbar);</pre> <p>Usually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component's data dependencies:</p> <pre class=\"highlight\" data-language=\"js\">const CommentWithRelay = Relay.createContainer(Comment, config);</pre> <p>The most common signature for HOCs looks like this:</p> <pre class=\"highlight\" data-language=\"js\">// React Redux's `connect`\nconst ConnectedComment = connect(commentSelector, commentActions)(Comment);</pre> <p><em>What?!</em> If you break it apart, it's easier to see what's going on.</p> <pre class=\"highlight\" data-language=\"js\">// connect is a function that returns another function\nconst enhance = connect(commentListSelector, commentListActions);\n// The returned function is an HOC, which returns a component that is connected\n// to the Redux store\nconst ConnectedComment = enhance(CommentList);</pre> <p>In other words, <code>connect</code> is a higher-order function that returns a higher-order component!</p> <p>This form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the <code>connect</code> function have the signature <code>Component =&gt; Component</code>. Functions whose output type is the same as its input type are really easy to compose together.</p> <pre class=\"highlight\" data-language=\"js\">// Instead of doing this...\nconst EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))\n\n// ... you can use a function composition utility\n// compose(f, g, h) is the same as (...args) =&gt; f(g(h(...args)))\nconst enhance = compose(\n  // These are both single-argument HOCs\n  connect(commentSelector),\n  withRouter\n)\nconst EnhancedComponent = enhance(WrappedComponent)</pre> <p>(This same property also allows <code>connect</code> and other enhancer-style HOCs to be used as decorators, an experimental JavaScript proposal.)</p> <p>The <code>compose</code> utility function is provided by many third-party libraries including lodash (as <a href=\"https://lodash.com/docs/#flowRight\"><code>lodash.flowRight</code></a>), <a href=\"http://redux.js.org/docs/api/compose.html\">Redux</a>, and <a href=\"http://ramdajs.com/docs/#compose\">Ramda</a>.</p> <h2 id=\"convention-wrap-the-display-name-for-easy-debugging\">\nConvention: Wrap the Display Name for Easy Debugging </h2> <p>The container components created by HOCs show up in the <a href=\"https://github.com/facebook/react-devtools\">React Developer Tools</a> like any other component. To ease debugging, choose a display name that communicates that it's the result of an HOC.</p> <p>The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named <code>withSubscription</code>, and the wrapped component's display name is <code>CommentList</code>, use the display name <code>WithSubscription(CommentList)</code>:</p> <pre class=\"highlight\" data-language=\"js\">function withSubscription(WrappedComponent) {\n  class WithSubscription extends React.Component {/* ... */}\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n  return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}</pre>\n<h2 id=\"caveats\">\nCaveats </h2> <p>Higher-order components come with a few caveats that aren't immediately obvious if you're new to React.</p> <h3 id=\"dont-use-hocs-inside-the-render-method\">\nDon't Use HOCs Inside the render Method </h3> <p>React's diffing algorithm (called reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from <code>render</code> is identical (<code>===</code>) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they're not equal, the previous subtree is unmounted completely.</p> <p>Normally, you shouldn't need to think about this. But it matters for HOCs because it means you can't apply an HOC to a component within the render method of a component:</p> <pre class=\"highlight\" data-language=\"js\">render() {\n  // A new version of EnhancedComponent is created on every render\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // That causes the entire subtree to unmount/remount each time!\n  return &lt;EnhancedComponent /&gt;;\n}</pre> <p>The problem here isn't just about performance — remounting a component causes the state of that component and all of its children to be lost.</p> <p>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</p> <p>In those rare cases where you need to apply an HOC dynamically, you can also do it inside a component's lifecycle methods or its constructor.</p> <h3 id=\"static-methods-must-be-copied-over\">\nStatic Methods Must Be Copied Over </h3> <p>Sometimes it's useful to define a static method on a React component. For example, Relay containers expose a static method <code>getFragment</code> to facilitate the composition of GraphQL fragments.</p> <p>When you apply an HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.</p> <pre class=\"highlight\" data-language=\"js\">// Define a static method\nWrappedComponent.staticMethod = function() {/*...*/}\n// Now apply an HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// The enhanced component has no static method\ntypeof EnhancedComponent.staticMethod === 'undefined' // true</pre> <p>To solve this, you could copy the methods onto the container before returning it:</p> <pre class=\"highlight\" data-language=\"js\">function enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // Must know exactly which method(s) to copy :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}</pre> <p>However, this requires you to know exactly which methods need to be copied. You can use <a href=\"https://github.com/mridgway/hoist-non-react-statics\">hoist-non-react-statics</a> to automatically copy all non-React static methods:</p> <pre class=\"highlight\" data-language=\"js\">import hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}</pre> <p>Another possible solution is to export the static method separately from the component itself.</p> <pre class=\"highlight\" data-language=\"js\">// Instead of...\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ...export the method separately...\nexport { someFunction };\n\n// ...and in the consuming module, import both\nimport MyComponent, { someFunction } from './MyComponent.js';</pre>\n<h3 id=\"refs-arent-passed-through\">\nRefs Aren't Passed Through </h3> <p>While the convention for higher-order components is to pass through all props to the wrapped component, it's not possible to pass through refs. That's because <code>ref</code> is not really a prop — like <code>key</code>, it's handled specially by React. If you add a ref to an element whose component is the result of an HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</p> <p>If you find yourself facing this problem, the ideal solution is to figure out how to avoid using <code>ref</code> at all. Occasionally, users who are new to the React paradigm rely on refs in situations where a prop would work better.</p> <p>That said, there are times when refs are a necessary escape hatch — React wouldn't support them otherwise. Focusing an input field is an example where you may want imperative control of a component. In that case, one solution is to pass a ref callback as a normal prop, by giving it a different name:</p> <pre class=\"highlight\" data-language=\"js\">function Field({ inputRef, ...rest }) {\n  return &lt;input ref={inputRef} {...rest} /&gt;;\n}\n\n// Wrap Field in a higher-order component\nconst EnhancedField = enhance(Field);\n\n// Inside a class component's render method...\n&lt;EnhancedField\n  inputRef={(inputEl) =&gt; {\n    // This callback gets passed through as a regular prop\n    this.inputEl = inputEl\n  }}\n/&gt;\n\n// Now you can call imperative methods\nthis.inputEl.focus();</pre> <p>This is not a perfect solution by any means. We prefer that refs remain a library concern, rather than require you to manually handle them. We are exploring ways to solve this problem so that using an HOC is unobservable.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/higher-order-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/higher-order-components.html</a>\n  </p>\n</div>\n","events":"<h1> SyntheticEvent </h1>  <p>This reference guide documents the <code>SyntheticEvent</code> wrapper that forms part of React's Event System. See the <a href=\"handling-events\">Handling Events</a> guide to learn more.</p> <h2 id=\"overview\">\nOverview </h2> <p>Your event handlers will be passed instances of <code>SyntheticEvent</code>, a cross-browser wrapper around the browser's native event. It has the same interface as the browser's native event, including <code>stopPropagation()</code> and <code>preventDefault()</code>, except the events work identically across all browsers.</p> <p>If you find that you need the underlying browser event for some reason, simply use the <code>nativeEvent</code> attribute to get it. Every <code>SyntheticEvent</code> object has the following attributes:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean bubbles\nboolean cancelable\nDOMEventTarget currentTarget\nboolean defaultPrevented\nnumber eventPhase\nboolean isTrusted\nDOMEvent nativeEvent\nvoid preventDefault()\nboolean isDefaultPrevented()\nvoid stopPropagation()\nboolean isPropagationStopped()\nDOMEventTarget target\nnumber timeStamp\nstring type</pre> <blockquote>  <p>As of v0.14, returning <code>false</code> from an event handler will no longer stop event propagation. Instead, <code>e.stopPropagation()</code> or <code>e.preventDefault()</code> should be triggered manually, as appropriate.</p> </blockquote> <h3 id=\"event-pooling\">\nEvent Pooling </h3> <p>The <code>SyntheticEvent</code> is pooled. This means that the <code>SyntheticEvent</code> object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</p> <pre class=\"highlight\" data-language=\"javascript\">function onClick(event) {\n  console.log(event); // =&gt; nullified object.\n  console.log(event.type); // =&gt; \"click\"\n  const eventType = event.type; // =&gt; \"click\"\n\n  setTimeout(function() {\n    console.log(event.type); // =&gt; null\n    console.log(eventType); // =&gt; \"click\"\n  }, 0);\n\n  // Won't work. this.state.clickEvent will only contain null values.\n  this.setState({clickEvent: event});\n\n  // You can still export event properties.\n  this.setState({eventType: event.type});\n}</pre> <blockquote>  <p>If you want to access the event properties in an asynchronous way, you should call <code>event.persist()</code> on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</p> </blockquote> <h2 id=\"supported-events\">\nSupported Events </h2> <p>React normalizes events so that they have consistent properties across different browsers.</p> <p>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append <code>Capture</code> to the event name; for example, instead of using <code>onClick</code>, you would use <code>onClickCapture</code> to handle the click event in the capture phase.</p> <ul> <li><a href=\"#clipboard-events\">Clipboard Events</a></li> <li><a href=\"#composition-events\">Composition Events</a></li> <li><a href=\"#keyboard-events\">Keyboard Events</a></li> <li><a href=\"#focus-events\">Focus Events</a></li> <li><a href=\"#form-events\">Form Events</a></li> <li><a href=\"#mouse-events\">Mouse Events</a></li> <li><a href=\"#selection-events\">Selection Events</a></li> <li><a href=\"#touch-events\">Touch Events</a></li> <li><a href=\"#ui-events\">UI Events</a></li> <li><a href=\"#wheel-events\">Wheel Events</a></li> <li><a href=\"#media-events\">Media Events</a></li> <li><a href=\"#image-events\">Image Events</a></li> <li><a href=\"#animation-events\">Animation Events</a></li> <li><a href=\"#transition-events\">Transition Events</a></li> </ul>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"clipboard-events\">\nClipboard Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onCopy onCut onPaste</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">DOMDataTransfer clipboardData</pre>  <h3 id=\"composition-events\">\nComposition Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onCompositionEnd onCompositionStart onCompositionUpdate</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string data</pre>  <h3 id=\"keyboard-events\">\nKeyboard Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onKeyDown onKeyPress onKeyUp</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nnumber charCode\nboolean ctrlKey\nboolean getModifierState(key)\nstring key\nnumber keyCode\nstring locale\nnumber location\nboolean metaKey\nboolean repeat\nboolean shiftKey\nnumber which</pre>  <h3 id=\"focus-events\">\nFocus Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onFocus onBlur</pre> <p>These focus events work on all elements in the React DOM, not just form elements.</p> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">DOMEventTarget relatedTarget</pre>  <h3 id=\"form-events\">\nForm Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onChange onInput onSubmit</pre> <p>For more information about the onChange event, see <a href=\"forms\">Forms</a>.</p>  <h3 id=\"mouse-events\">\nMouse Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit\nonDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave\nonMouseMove onMouseOut onMouseOver onMouseUp</pre> <p>The <code>onMouseEnter</code> and <code>onMouseLeave</code> events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</p> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nnumber button\nnumber buttons\nnumber clientX\nnumber clientY\nboolean ctrlKey\nboolean getModifierState(key)\nboolean metaKey\nnumber pageX\nnumber pageY\nDOMEventTarget relatedTarget\nnumber screenX\nnumber screenY\nboolean shiftKey</pre>  <h3 id=\"selection-events\">\nSelection Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onSelect</pre>  <h3 id=\"touch-events\">\nTouch Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onTouchCancel onTouchEnd onTouchMove onTouchStart</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nDOMTouchList changedTouches\nboolean ctrlKey\nboolean getModifierState(key)\nboolean metaKey\nboolean shiftKey\nDOMTouchList targetTouches\nDOMTouchList touches</pre>  <h3 id=\"ui-events\">\nUI Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onScroll</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">number detail\nDOMAbstractView view</pre>  <h3 id=\"wheel-events\">\nWheel Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onWheel</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">number deltaMode\nnumber deltaX\nnumber deltaY\nnumber deltaZ</pre>  <h3 id=\"media-events\">\nMedia Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted \nonEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay \nonPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend \nonTimeUpdate onVolumeChange onWaiting</pre>  <h3 id=\"image-events\">\nImage Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onLoad onError</pre>  <h3 id=\"animation-events\">\nAnimation Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onAnimationStart onAnimationEnd onAnimationIteration</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string animationName\nstring pseudoElement\nfloat elapsedTime</pre>  <h3 id=\"transition-events\">\nTransition Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onTransitionEnd</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string propertyName\nstring pseudoElement\nfloat elapsedTime</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/events.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/events.html</a>\n  </p>\n</div>\n","react-component":"<h1> React.Component </h1>  <p><a href=\"components-and-props\">Components</a> let you split the UI into independent, reusable pieces, and think about each piece in isolation. <code>React.Component</code> is provided by <a href=\"react-api\"><code>React</code></a>.</p> <h2 id=\"overview\">\nOverview </h2> <p><code>React.Component</code> is an abstract base class, so it rarely makes sense to refer to <code>React.Component</code> directly. Instead, you will typically subclass it, and define at least a <a href=\"#render\"><code>render()</code></a> method.</p> <p>Normally you would define a React component as a plain <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">JavaScript class</a>:</p> <pre class=\"highlight\" data-language=\"javascript\">class Greeting extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}</pre> <p>If you don't use ES6 yet, you may use the <a href=\"react-api#createclass\"><code>React.createClass</code></a> helper instead. Take a look at <a href=\"react-without-es6\">Using React without ES6</a> to learn more.</p> <h3 id=\"the-component-lifecycle\">\nThe Component Lifecycle </h3> <p>Each component has several \"lifecycle methods\" that you can override to run code at particular times in the process. Methods prefixed with <strong><code>will</code></strong> are called right before something happens, and methods prefixed with <strong><code>did</code></strong> are called right after something happens.</p> <h4 id=\"mounting\">\nMounting </h4> <p>These methods are called when an instance of a component is being created and inserted into the DOM:</p> <ul> <li><a href=\"#constructor\"><code>constructor()</code></a></li> <li><a href=\"#componentwillmount\"><code>componentWillMount()</code></a></li> <li><a href=\"#render\"><code>render()</code></a></li> <li><a href=\"#componentdidmount\"><code>componentDidMount()</code></a></li> </ul> <h4 id=\"updating\">\nUpdating </h4> <p>An update can be caused by changes to props or state. These methods are called when a component is being re-rendered:</p> <ul> <li><a href=\"#componentwillreceiveprops\"><code>componentWillReceiveProps()</code></a></li> <li><a href=\"#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a></li> <li><a href=\"#componentwillupdate\"><code>componentWillUpdate()</code></a></li> <li><a href=\"#render\"><code>render()</code></a></li> <li><a href=\"#componentdidupdate\"><code>componentDidUpdate()</code></a></li> </ul> <h4 id=\"unmounting\">\nUnmounting </h4> <p>This method is called when a component is being removed from the DOM:</p> <ul> <li><a href=\"#componentwillunmount\"><code>componentWillUnmount()</code></a></li> </ul> <h3 id=\"other-apis\">\nOther APIs </h3> <p>Each component also provides some other APIs:</p> <ul> <li><a href=\"#setstate\"><code>setState()</code></a></li> <li><a href=\"#forceupdate\"><code>forceUpdate()</code></a></li> </ul> <h3 id=\"class-properties\">\nClass Properties </h3> <ul> <li><a href=\"#defaultprops\"><code>defaultProps</code></a></li> <li><a href=\"#displayname\"><code>displayName</code></a></li> <li><a href=\"#proptypes\"><code>propTypes</code></a></li> </ul> <h3 id=\"instance-properties\">\nInstance Properties </h3> <ul> <li><a href=\"#props\"><code>props</code></a></li> <li><a href=\"#state\"><code>state</code></a></li> </ul>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"render\">\n<code>render()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">render()</pre> <p>The <code>render()</code> method is required.</p> <p>When called, it should examine <code>this.props</code> and <code>this.state</code> and return a single React element. This element can be either a representation of a native DOM component, such as <code>&lt;div /&gt;</code>, or another composite component that you've defined yourself.</p> <p>You can also return <code>null</code> or <code>false</code> to indicate that you don't want anything rendered. When returning <code>null</code> or <code>false</code>, <code>ReactDOM.findDOMNode(this)</code> will return <code>null</code>.</p> <p>The <code>render()</code> function should be pure, meaning that it does not modify component state, it returns the same result each time it's invoked, and it does not directly interact with the browser. If you need to interact with the browser, perform your work in <code>componentDidMount()</code> or the other lifecycle methods instead. Keeping <code>render()</code> pure makes components easier to think about.</p> <blockquote> <p>Note</p> <p><code>render()</code> will not be invoked if <a href=\"#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a> returns false.</p> </blockquote>  <h3 id=\"constructor\">\n<code>constructor()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">constructor(props)</pre> <p>The constructor for a React component is called before it is mounted. When implementing the constructor for a <code>React.Component</code> subclass, you should call <code>super(props)</code> before any other statement. Otherwise, <code>this.props</code> will be undefined in the constructor, which can lead to bugs.</p> <p>The constructor is the right place to initialize state. If you don't initialize state and you don't bind methods, you don't need to implement a constructor for your React component.</p> <p>It's okay to initialize state based on props if you know what you're doing. Here's an example of a valid <code>React.Component</code> subclass constructor:</p> <pre class=\"highlight\" data-language=\"js\">constructor(props) {\n  super(props);\n  this.state = {\n    color: props.initialColor\n  };\n}</pre> <p>Beware of this pattern, as it effectively \"forks\" the props and can lead to bugs. Instead of syncing props to state, you often want to <a href=\"lifting-state-up\">lift the state up</a>.</p> <p>If you \"fork\" props by using them for state, you might also want to implement <a href=\"#componentwillreceiveprops\"><code>componentWillReceiveProps(nextProps)</code></a> to keep the state up-to-date with them. But lifting state up is often easier and less bug-prone.</p>  <h3 id=\"componentwillmount\">\n<code>componentWillMount()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillMount()</pre> <p><code>componentWillMount()</code> is invoked immediately before mounting occurs. It is called before <code>render()</code>, therefore setting state in this method will not trigger a re-rendering. Avoid introducing any side-effects or subscriptions in this method.</p> <p>This is the only lifecycle hook called on server rendering. Generally, we recommend using the <code>constructor()</code> instead.</p>  <h3 id=\"componentdidmount\">\n<code>componentDidMount()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentDidMount()</pre> <p><code>componentDidMount()</code> is invoked immediately after a component is mounted. Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request. Setting state in this method will trigger a re-rendering.</p>  <h3 id=\"componentwillreceiveprops\">\n<code>componentWillReceiveProps()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillReceiveProps(nextProps)</pre> <p><code>componentWillReceiveProps()</code> is invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare <code>this.props</code> and <code>nextProps</code> and perform state transitions using <code>this.setState()</code> in this method.</p> <p>Note that React may call this method even if the props have not changed, so make sure to compare the current and next values if you only want to handle changes. This may occur when the parent component causes your component to re-render.</p> <p>React doesn't call <code>componentWillReceiveProps</code> with initial props during <a href=\"#mounting\">mounting</a>. It only calls this method if some of component's props may update. Calling <code>this.setState</code> generally doesn't trigger <code>componentWillReceiveProps</code>.</p>  <h3 id=\"shouldcomponentupdate\">\n<code>shouldComponentUpdate()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate(nextProps, nextState)</pre> <p>Use <code>shouldComponentUpdate()</code> to let React know if a component's output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.</p> <p><code>shouldComponentUpdate()</code> is invoked before rendering when new props or state are being received. Defaults to <code>true</code>. This method is not called for the initial render or when <code>forceUpdate()</code> is used.</p> <p>Returning <code>false</code> does not prevent child components from re-rendering when <em>their</em> state changes.</p> <p>Currently, if <code>shouldComponentUpdate()</code> returns <code>false</code>, then <a href=\"#componentwillupdate\"><code>componentWillUpdate()</code></a>, <a href=\"#render\"><code>render()</code></a>, and <a href=\"#componentdidupdate\"><code>componentDidUpdate()</code></a> will not be invoked. Note that in the future React may treat <code>shouldComponentUpdate()</code> as a hint rather than a strict directive, and returning <code>false</code> may still result in a re-rendering of the component.</p> <p>If you determine a specific component is slow after profiling, you may change it to inherit from <a href=\"react-api#react.purecomponent\"><code>React.PureComponent</code></a> which implements <code>shouldComponentUpdate()</code> with a shallow prop and state comparison. If you are confident you want to write it by hand, you may compare <code>this.props</code> with <code>nextProps</code> and <code>this.state</code> with <code>nextState</code> and return <code>false</code> to tell React the update can be skipped.</p>  <h3 id=\"componentwillupdate\">\n<code>componentWillUpdate()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillUpdate(nextProps, nextState)</pre> <p><code>componentWillUpdate()</code> is invoked immediately before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.</p> <p>Note that you cannot call <code>this.setState()</code> here. If you need to update state in response to a prop change, use <code>componentWillReceiveProps()</code> instead.</p> <blockquote> <p>Note</p> <p><code>componentWillUpdate()</code> will not be invoked if <a href=\"#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a> returns false.</p> </blockquote>  <h3 id=\"componentdidupdate\">\n<code>componentDidUpdate()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentDidUpdate(prevProps, prevState)</pre> <p><code>componentDidUpdate()</code> is invoked immediately after updating occurs. This method is not called for the initial render.</p> <p>Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</p> <blockquote> <p>Note</p> <p><code>componentDidUpdate()</code> will not be invoked if <a href=\"#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a> returns false.</p> </blockquote>  <h3 id=\"componentwillunmount\">\n<code>componentWillUnmount()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">componentWillUnmount()</pre> <p><code>componentWillUnmount()</code> is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any DOM elements that were created in <code>componentDidMount</code></p>  <h3 id=\"setstate\">\n<code>setState()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">setState(nextState, callback)</pre> <p>Performs a shallow merge of nextState into current state. This is the primary method you use to trigger UI updates from event handlers and server request callbacks.</p> <p>The first argument can be an object (containing zero or more keys to update) or a function (of state and props) that returns an object containing keys to update.</p> <p>Here is the simple object usage:</p> <pre class=\"highlight\" data-language=\"javascript\">this.setState({mykey: 'my new value'});</pre> <p>It's also possible to pass a function with the signature <code>function(state, props) =&gt; newState</code>. This enqueues an atomic update that consults the previous value of state and props before setting any values. For instance, suppose we wanted to increment a value in state by <code>props.step</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">this.setState((prevState, props) =&gt; {\n  return {myInteger: prevState.myInteger + props.step};\n});</pre> <p>The second parameter is an optional callback function that will be executed once <code>setState</code> is completed and the component is re-rendered. Generally we recommend using <code>componentDidUpdate()</code> for such logic instead.</p> <p><code>setState()</code> does not immediately mutate <code>this.state</code> but creates a pending state transition. Accessing <code>this.state</code> after calling this method can potentially return the existing value.</p> <p>There is no guarantee of synchronous operation of calls to <code>setState</code> and calls may be batched for performance gains.</p> <p><code>setState()</code> will always lead to a re-render unless <code>shouldComponentUpdate()</code> returns <code>false</code>. If mutable objects are being used and conditional rendering logic cannot be implemented in <code>shouldComponentUpdate()</code>, calling <code>setState()</code> only when the new state differs from the previous state will avoid unnecessary re-renders.</p>  <h3 id=\"forceupdate\">\n<code>forceUpdate()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">component.forceUpdate(callback)</pre> <p>By default, when your component's state or props change, your component will re-render. If your <code>render()</code> method depends on some other data, you can tell React that the component needs re-rendering by calling <code>forceUpdate()</code>.</p> <p>Calling <code>forceUpdate()</code> will cause <code>render()</code> to be called on the component, skipping <code>shouldComponentUpdate()</code>. This will trigger the normal lifecycle methods for child components, including the <code>shouldComponentUpdate()</code> method of each child. React will still only update the DOM if the markup changes.</p> <p>Normally you should try to avoid all uses of <code>forceUpdate()</code> and only read from <code>this.props</code> and <code>this.state</code> in <code>render()</code>.</p>  <h2 id=\"class-properties\">\nClass Properties </h2>\n<h3 id=\"defaultprops\">\n<code>defaultProps</code> </h3> <p><code>defaultProps</code> can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props. For example:</p> <pre class=\"highlight\" data-language=\"js\">class CustomButton extends React.Component {\n  // ...\n}\n\nCustomButton.defaultProps = {\n  color: 'blue'\n};</pre> <p>If <code>props.color</code> is not provided, it will be set by default to <code>'blue'</code>:</p> <pre class=\"highlight\" data-language=\"js\">render() {\n    return &lt;CustomButton /&gt; ; // props.color will be set to blue\n  }</pre> <p>If <code>props.color</code> is set to null, it will remain null:</p> <pre class=\"highlight\" data-language=\"js\">render() {\n    return &lt;CustomButton color={null} /&gt; ; // props.color will remain null\n  }</pre>  <h3 id=\"displayname\">\n<code>displayName</code> </h3> <p>The <code>displayName</code> string is used in debugging messages. JSX sets this value automatically; see <a href=\"jsx-in-depth\">JSX in Depth</a>.</p>  <h3 id=\"proptypes\">\n<code>propTypes</code> </h3> <p><code>propTypes</code> can be defined as a property on the component class itself, to define what types the props should be. It should be a map from prop names to types as defined in <a href=\"react-api#react.proptypes\"><code>React.PropTypes</code></a>. In development mode, when an invalid value is provided for a prop, a warning will be shown in the JavaScript console. In production mode, <code>propTypes</code> checks are skipped for efficiency.</p> <p>For example, this code ensures that the <code>color</code> prop is a string:</p> <pre class=\"highlight\" data-language=\"js\">class CustomButton extends React.Component {\n  // ...\n}\n\nCustomButton.propTypes = {\n  color: React.PropTypes.string\n};</pre> <p>We recommend using <a href=\"https://flowtype.org/\">Flow</a> when possible, to get compile-time typechecking instead of runtime typechecking. <a href=\"https://flowtype.org/docs/react.html\">Flow has built-in support for React</a> so it's easy to run static analysis on a React app.</p>  <h2 id=\"instance-properties\">\nInstance Properties </h2>\n<h2 id=\"props\">\n<code>props</code> </h2> <p><code>this.props</code> contains the props that were defined by the caller of this component. See <a href=\"components-and-props\">Components and Props</a> for an introduction to props.</p> <p>In particular, <code>this.props.children</code> is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</p> <h3 id=\"state\">\n<code>state</code> </h3> <p>The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.</p> <p>If you don't use it in <code>render()</code>, it shouldn't be on the state. For example, you can put timer IDs directly on the instance.</p> <p>See <a href=\"state-and-lifecycle\">State and Lifecycle</a> for more information about the state.</p> <p>Never mutate <code>this.state</code> directly, as calling <code>setState()</code> afterwards may replace the mutation you made. Treat <code>this.state</code> as if it were immutable.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/react-component.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/react-component.html</a>\n  </p>\n</div>\n","two-way-binding-helpers":"<h1> Two-way Binding Helpers </h1>  <blockquote> <p>Note: <code>LinkedStateMixin</code> is deprecated as of React v15. The recommendation is to explicitly set the value and change handler, instead of using <code>LinkedStateMixin</code>.</p> </blockquote> <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import LinkedStateMixin from 'react-addons-linked-state-mixin' // ES6\nvar LinkedStateMixin = require('react-addons-linked-state-mixin') // ES5 with npm\nvar LinkedStateMixin = React.addons.LinkedStateMixin; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p><code>LinkedStateMixin</code> is an easy way to express two-way binding with React.</p> <p>In React, data flows one way: from owner to child. This is because data only flows one direction in <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_architecture\">the Von Neumann model of computing</a>. You can think of it as \"one-way data binding.\"</p> <p>However, there are lots of applications that require you to read some data and flow it back into your program. For example, when developing forms, you'll often want to update some React <code>state</code> when you receive user input. Or perhaps you want to perform layout in JavaScript and react to changes in some DOM element size.</p> <p>In React, you would implement this by listening to a \"change\" event, read from your data source (usually the DOM) and call <code>setState()</code> on one of your components. \"Closing the data flow loop\" explicitly leads to more understandable and easier-to-maintain programs. See <a href=\"forms\">our forms documentation</a> for more information.</p> <p>Two-way binding -- implicitly enforcing that some value in the DOM is always consistent with some React <code>state</code> -- is concise and supports a wide variety of applications. We've provided <code>LinkedStateMixin</code>: syntactic sugar for setting up the common data flow loop pattern described above, or \"linking\" some data source to React <code>state</code>.</p> <blockquote>  <p><code>LinkedStateMixin</code> is just a thin wrapper and convention around the <code>onChange</code>/<code>setState()</code> pattern. It doesn't fundamentally change how data flows in your React application.</p> </blockquote> <h2 id=\"linkedstatemixin-before-and-after\">\nLinkedStateMixin: Before and After </h2> <p>Here's a simple form example without using <code>LinkedStateMixin</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">var NoLink = React.createClass({\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  handleChange: function(event) {\n    this.setState({message: event.target.value});\n  },\n  render: function() {\n    var message = this.state.message;\n    return &lt;input type=\"text\" value={message} onChange={this.handleChange} /&gt;;\n  }\n});</pre> <p>This works really well and it's very clear how data is flowing, however, with a lot of form fields it could get a bit verbose. Let's use <code>LinkedStateMixin</code> to save us some typing:</p> <pre class=\"highlight\" data-language=\"javascript\">var WithLink = React.createClass({\n  mixins: [LinkedStateMixin],\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  render: function() {\n    return &lt;input type=\"text\" valueLink={this.linkState('message')} /&gt;;\n  }\n});</pre> <p><code>LinkedStateMixin</code> adds a method to your React component called <code>linkState()</code>. <code>linkState()</code> returns a <code>valueLink</code> object which contains the current value of the React state and a callback to change it.</p> <p><code>valueLink</code> objects can be passed up and down the tree as props, so it's easy (and explicit) to set up two-way binding between a component deep in the hierarchy and state that lives higher in the hierarchy.</p> <p>Note that checkboxes have a special behavior regarding their <code>value</code> attribute, which is the value that will be sent on form submit if the checkbox is checked (defaults to <code>on</code>). The <code>value</code> attribute is not updated when the checkbox is checked or unchecked. For checkboxes, you should use <code>checkedLink</code> instead of <code>valueLink</code>: <code>\n&lt;input type=\"checkbox\" checkedLink={this.linkState('booleanValue')} /&gt;\n</code></p> <h2 id=\"under-the-hood\">\nUnder the Hood </h2> <p>There are two sides to <code>LinkedStateMixin</code>: the place where you create the <code>valueLink</code> instance and the place where you use it. To prove how simple <code>LinkedStateMixin</code> is, let's rewrite each side separately to be more explicit.</p> <h3 id=\"valuelink-without-linkedstatemixin\">\nvalueLink Without LinkedStateMixin </h3>\n<pre class=\"highlight\" data-language=\"javascript\">var WithoutMixin = React.createClass({\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  handleChange: function(newValue) {\n    this.setState({message: newValue});\n  },\n  render: function() {\n    var valueLink = {\n      value: this.state.message,\n      requestChange: this.handleChange\n    };\n    return &lt;input type=\"text\" valueLink={valueLink} /&gt;;\n  }\n});</pre> <p>As you can see, <code>valueLink</code> objects are very simple objects that just have a <code>value</code> and <code>requestChange</code> prop. And <code>LinkedStateMixin</code> is similarly simple: it just populates those fields with a value from <code>this.state</code> and a callback that calls <code>this.setState()</code>.</p> <h3 id=\"linkedstatemixin-without-valuelink\">\nLinkedStateMixin Without valueLink </h3>\n<pre class=\"highlight\" data-language=\"javascript\">var LinkedStateMixin = require('react-addons-linked-state-mixin');\n\nvar WithoutLink = React.createClass({\n  mixins: [LinkedStateMixin],\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  render: function() {\n    var valueLink = this.linkState('message');\n    var handleChange = function(e) {\n      valueLink.requestChange(e.target.value);\n    };\n    return &lt;input type=\"text\" value={valueLink.value} onChange={handleChange} /&gt;;\n  }\n});</pre> <p>The <code>valueLink</code> prop is also quite simple. It simply handles the <code>onChange</code> event and calls <code>this.props.valueLink.requestChange()</code> and also uses <code>this.props.valueLink.value</code> instead of <code>this.props.value</code>. That's it!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/two-way-binding-helpers.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/two-way-binding-helpers.html</a>\n  </p>\n</div>\n","test-utils":"<h1> Test Utilities </h1>  <p><strong>Importing</strong></p> <pre class=\"highlight\" data-language=\"javascript\">import ReactTestUtils from 'react-addons-test-utils' // ES6\nvar ReactTestUtils = require('react-addons-test-utils') // ES5 with npm\nvar ReactTestUtils = React.addons.TestUtils; // ES5 with react-with-addons.js</pre>\n<h2 id=\"overview\">\nOverview </h2> <p><code>ReactTestUtils</code> makes it easy to test React components in the testing framework of your choice. At Facebook we use <a href=\"https://facebook.github.io/jest/\">Jest</a> for painless JavaScript testing. Learn how to get started with Jest through the Jest website's <a href=\"http://facebook.github.io/jest/docs/tutorial-react.html#content\">React Tutorial</a>.</p> <blockquote>  <p>Airbnb has released a testing utility called Enzyme, which makes it easy to assert, manipulate, and traverse your React Components' output. If you're deciding on a unit testing utility to use together with Jest, or any other test runner, it's worth checking out: <a href=\"http://airbnb.io/enzyme/\">http://airbnb.io/enzyme/</a></p> </blockquote> <ul> <li><a href=\"#simulate\"><code>Simulate</code></a></li> <li><a href=\"#renderintodocument\"><code>renderIntoDocument()</code></a></li> <li><a href=\"#mockcomponent\"><code>mockComponent()</code></a></li> <li><a href=\"#iselement\"><code>isElement()</code></a></li> <li><a href=\"#iselementoftype\"><code>isElementOfType()</code></a></li> <li><a href=\"#isdomcomponent\"><code>isDOMComponent()</code></a></li> <li><a href=\"#iscompositecomponent\"><code>isCompositeComponent()</code></a></li> <li><a href=\"#iscompositecomponentwithtype\"><code>isCompositeComponentWithType()</code></a></li> <li><a href=\"#findallinrenderedtree\"><code>findAllInRenderedTree()</code></a></li> <li><a href=\"#scryrendereddomcomponentswithclass\"><code>scryRenderedDOMComponentsWithClass()</code></a></li> <li><a href=\"#findrendereddomcomponentwithclass\"><code>findRenderedDOMComponentWithClass()</code></a></li> <li><a href=\"#scryrendereddomcomponentswithtag\"><code>scryRenderedDOMComponentsWithTag()</code></a></li> <li><a href=\"#findrendereddomcomponentwithtag\"><code>findRenderedDOMComponentWithTag()</code></a></li> <li><a href=\"#scryrenderedcomponentswithtype\"><code>scryRenderedComponentsWithType()</code></a></li> <li><a href=\"#findrenderedcomponentwithtype\"><code>findRenderedComponentWithType()</code></a></li> </ul> <h3 id=\"shallow-rendering\">\nShallow Rendering </h3> <p>Shallow rendering lets you render a component \"one level deep\" and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</p> <ul> <li><a href=\"#createrenderer\"><code>createRenderer()</code></a></li> <li><a href=\"#shallowrenderer.render\"><code>shallowRenderer.render()</code></a></li> <li><a href=\"#shallowrenderer.getrenderoutput\"><code>shallowRenderer.getRenderOutput()</code></a></li> </ul> <p>Call <a href=\"#createrenderer\"><code>createRenderer()</code></a> in your tests to create a shallow renderer. You can think of this as a \"place\" to render the component you're testing, and from which you can extract the component's output.</p> <p><a href=\"#shallowrenderer.render\"><code>shallowRenderer.render()</code></a> is similar to <a href=\"react-dom#render\"><code>ReactDOM.render()</code></a> but it doesn't require DOM and only renders a single level deep. This means you can test components isolated from how their children are implemented.</p> <p>After <code>shallowRenderer.render()</code> has been called, you can use <a href=\"#shallowrenderer.getrenderoutput\"><code>shallowRenderer.getRenderOutput()</code></a> to get the shallowly rendered output.</p> <p>You can then begin to assert facts about the output. For example, if you have the following component:</p> <pre class=\"highlight\" data-language=\"javascript\">function MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;span className=\"heading\"&gt;Title&lt;/span&gt;\n      &lt;Subcomponent foo=\"bar\" /&gt;\n    &lt;/div&gt;\n  );\n}</pre> <p>Then you can assert:</p> <pre class=\"highlight\" data-language=\"javascript\">const renderer = ReactTestUtils.createRenderer();\nrenderer.render(&lt;MyComponent /&gt;);\nconst result = renderer.getRenderOutput();\n\nexpect(result.type).toBe('div');\nexpect(result.props.children).toEqual([\n  &lt;span className=\"heading\"&gt;Title&lt;/span&gt;,\n  &lt;Subcomponent foo=\"bar\" /&gt;\n]);</pre> <p>Shallow testing currently has some limitations, namely not supporting refs.</p> <p>We also recommend checking out Enzyme's <a href=\"http://airbnb.io/enzyme/docs/api/shallow.html\">Shallow Rendering API</a>. It provides a nicer higher-level API over the same functionality.</p>  <h2 id=\"reference\">\nReference </h2>\n<h3 id=\"simulate\">\n<code>Simulate</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Simulate.{eventName}(\n  element,\n  [eventData]\n)</pre> <p>Simulate an event dispatch on a DOM node with optional <code>eventData</code> event data.</p> <p><code>Simulate</code> has a method for <a href=\"events#supported-events\">every event that React understands</a>.</p> <p><strong>Clicking an element</strong></p> <pre class=\"highlight\" data-language=\"javascript\">// &lt;button ref=\"button\"&gt;...&lt;/button&gt;\nconst node = this.refs.button;\nReactTestUtils.Simulate.click(node);</pre> <p><strong>Changing the value of an input field and then pressing ENTER.</strong></p> <pre class=\"highlight\" data-language=\"javascript\">// &lt;input ref=\"input\" /&gt;\nconst node = this.refs.input;\nnode.value = 'giraffe';\nReactTestUtils.Simulate.change(node);\nReactTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});</pre> <blockquote> <p>Note</p> <p>You will have to provide any event property that you're using in your component (e.g. keyCode, which, etc...) as React is not creating any of these for you.</p> </blockquote>  <h3 id=\"renderintodocument\">\n<code>renderIntoDocument()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">renderIntoDocument(element)</pre> <p>Render a React element into a detached DOM node in the document. <strong>This function requires a DOM.</strong></p> <blockquote>  <p>You will need to have <code>window</code>, <code>window.document</code> and <code>window.document.createElement</code> globally available <strong>before</strong> you import <code>React</code>. Otherwise React will think it can't access the DOM and methods like <code>setState</code> won't work.</p> </blockquote>  <h3 id=\"mockcomponent\">\n<code>mockComponent()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">mockComponent(\n  componentClass,\n  [mockTagName]\n)</pre> <p>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple <code>&lt;div&gt;</code> (or other tag if <code>mockTagName</code> is provided) containing any provided children.</p>  <h3 id=\"iselement\">\n<code>isElement()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">isElement(element)</pre> <p>Returns <code>true</code> if <code>element</code> is any React element.</p>  <h3 id=\"iselementoftype\">\n<code>isElementOfType()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">isElementOfType(\n  element,\n  componentClass\n)</pre> <p>Returns <code>true</code> if <code>element</code> is a React element whose type is of a React <code>componentClass</code>.</p>  <h3 id=\"isdomcomponent\">\n<code>isDOMComponent()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">isDOMComponent(instance)</pre> <p>Returns <code>true</code> if <code>instance</code> is a DOM component (such as a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code>).</p>  <h3 id=\"iscompositecomponent\">\n<code>isCompositeComponent()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">isCompositeComponent(instance)</pre> <p>Returns <code>true</code> if <code>instance</code> is a user-defined component, such as a class or a function.</p>  <h3 id=\"iscompositecomponentwithtype\">\n<code>isCompositeComponentWithType()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">isCompositeComponentWithType(\n  instance,\n  componentClass\n)</pre> <p>Returns <code>true</code> if <code>instance</code> is a component whose type is of a React <code>componentClass</code>.</p>  <h3 id=\"findallinrenderedtree\">\n<code>findAllInRenderedTree()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">findAllInRenderedTree(\n  tree,\n  test\n)</pre> <p>Traverse all components in <code>tree</code> and accumulate all components where <code>test(component)</code> is <code>true</code>. This is not that useful on its own, but it's used as a primitive for other test utils.</p>  <h3 id=\"scryrendereddomcomponentswithclass\">\n<code>scryRenderedDOMComponentsWithClass()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">scryRenderedDOMComponentsWithClass(\n  tree,\n  className\n)</pre> <p>Finds all DOM elements of components in the rendered tree that are DOM components with the class name matching <code>className</code>.</p>  <h3 id=\"findrendereddomcomponentwithclass\">\n<code>findRenderedDOMComponentWithClass()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">findRenderedDOMComponentWithClass(\n  tree,\n  className\n)</pre> <p>Like <a href=\"#scryrendereddomcomponentswithclass\"><code>scryRenderedDOMComponentsWithClass()</code></a> but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</p>  <h3 id=\"scryrendereddomcomponentswithtag\">\n<code>scryRenderedDOMComponentsWithTag()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">scryRenderedDOMComponentsWithTag(\n  tree,\n  tagName\n)</pre> <p>Finds all DOM elements of components in the rendered tree that are DOM components with the tag name matching <code>tagName</code>.</p>  <h3 id=\"findrendereddomcomponentwithtag\">\n<code>findRenderedDOMComponentWithTag()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">findRenderedDOMComponentWithTag(\n  tree,\n  tagName\n)</pre> <p>Like <a href=\"#scryrendereddomcomponentswithtag\"><code>scryRenderedDOMComponentsWithTag()</code></a> but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</p>  <h3 id=\"scryrenderedcomponentswithtype\">\n<code>scryRenderedComponentsWithType()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">scryRenderedComponentsWithType(\n  tree,\n  componentClass\n)</pre> <p>Finds all instances of components with type equal to <code>componentClass</code>.</p>  <h3 id=\"findrenderedcomponentwithtype\">\n<code>findRenderedComponentWithType()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">findRenderedComponentWithType(\n  tree,\n  componentClass\n)</pre> <p>Same as <a href=\"#scryrenderedcomponentswithtype\"><code>scryRenderedComponentsWithType()</code></a> but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</p>  <h2 id=\"shallow-rendering\">\nShallow Rendering </h2>\n<h3 id=\"createrenderer\">\n<code>createRenderer()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">createRenderer()</pre> <p>Call this in your tests to create a <a href=\"#shallow-rendering\">shallow renderer</a>.</p>  <h3 id=\"shallowrenderer.render\">\n<code>shallowRenderer.render()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">shallowRenderer.render(\n  element\n)</pre> <p>Similar to <a href=\"react-dom#render\"><code>ReactDOM.render</code></a> but it doesn't require DOM and only renders a single level deep. See <a href=\"#shallow-rendering\">Shallow Rendering</a>.</p>  <h3 id=\"shallowrenderer.getrenderoutput\">\n<code>shallowRenderer.getRenderOutput()</code> </h3>\n<pre class=\"highlight\" data-language=\"javascript\">shallowRenderer.getRenderOutput()</pre> <p>After <a href=\"#shallowrenderer.render\"><code>shallowRenderer.render()</code></a> has been called, returns shallowly rendered output.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/test-utils.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/test-utils.html</a>\n  </p>\n</div>\n"}